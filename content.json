{"meta":{"title":"Error","subtitle":"","description":"","author":"Zhou muyun","url":"http://zhoumuyun.com","root":"/"},"pages":[{"title":"分类","date":"2023-12-02T12:00:16.000Z","updated":"2023-12-02T12:01:33.092Z","comments":true,"path":"categories/index.html","permalink":"http://zhoumuyun.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-12-02T11:55:30.000Z","updated":"2023-12-02T11:58:17.602Z","comments":true,"path":"tags/index.html","permalink":"http://zhoumuyun.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"python的函数说明","slug":"python的函数说明","date":"2023-12-03T08:22:58.000Z","updated":"2023-12-03T08:24:12.746Z","comments":true,"path":"2023/12/03/python的函数说明/","link":"","permalink":"http://zhoumuyun.com/2023/12/03/python%E7%9A%84%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E/","excerpt":"此篇介绍了函数的参数、函数的作用域、闭包、函数的装饰器、迭代器、推导式、生成器、匿名函数、内置函数","text":"此篇介绍了函数的参数、函数的作用域、闭包、函数的装饰器、迭代器、推导式、生成器、匿名函数、内置函数 函数的参数列表传入函数有对应的方法*arg表示传递任何参数 **kwarg传递任何字典参数 *,**\\表示接受所有参数，打包成元组和字典 *args一定是一个元组，**kwargs一定是一个字典 12345stu_list = [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;]def func(*arg):#*代表传递任何参数 print(arg)func(*stu_list)#*在实参位置，把列表打成位置参数进行传递，但是很不常见 #**在实参位置，可以把字典自动转化为关键字参数进行传递 关于return返回值：函数执行之后，会给调用方一个结果，这个结果就是返回值 1，如果函数内没有return，此时外界收到的None 2，函数只要执行到了return，函数就会立即停止并返回内容，函数内的return的后续代码不会执行 3，如果写了return ​ 只写了return，后面不跟数据，此时收到的依然是None ​ return 值，此时表示函数有一个返回值，外界能够接收到一个数据 ​ return 值1，值2，值3…..，此时函数有多个返回值，外界收到的是一个元组 123456def func(): print(123) return #会让程序停止，后续代码不会继续执行，类似循环里面的break print（456）ret = func()print(ret)#这里的函数代码指挥执行到123 1234def func(): return 1,2,3,4ret = func()print(ret) #收到的是一个元组数据 (1,2,3,4) 函数的作用域global:在局部（在函数中），引入全局变量 nonlocal：在局部，引入外层的局部变量，从内到外，一层一层往外找。如果有就引入，如果没有就继续向外，直到全局（不包括全局） 1234567def func(): a = 10 def func2(): a = 20 def func3(): nonlocal a #这里引入的是fun2的a a =30 #更改的是func2中a的值 123456a = 10def func(): global a #把全局变量引入到局部 a = 20func()print(a) #这里a就更改为20了 闭包1，可以让一个变量常驻于内存 2，避免全局变量被修改 123456789def func(): a = 10 #变量在函数体内部，不能通过global去修改，只能调用inner函数 def inner(): nonlocal a #应用上一次的变量a return a return inner #返回 调用inner函数ret = func() #返回了一个a值r1 = ret()print(r1) 函数的装饰器装饰器本质上是一个 Python 函数或类，它可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能，装饰器的返回值也是一个函数&#x2F;类对象 在运行函数前，将函数传入到装饰器里面，会先运行这个函数前的装饰器 比较适应于登录验证操作 1234567891011121314def wrapper(fn):#wrapper 装饰器 fn 目标函数 def inner(*arg,**kwargs):#*,**表示接受所有参数，打包成元组和字典 #在目标函数执行之前... ret = fn(*args,**kwargs) #目标函数 #在目标函数执行之后... return ret return inner#注意不能加()@wrapper #声明装饰器def target(): passtarget() # =&gt; inner()#将target传入wrapper(),wrapper(target)&gt;inner()#一个函数可以被多个装饰器装饰 #规则和规律 wrapper1 wrapper2 tagert wrapper2 wrapper1 12345678910111213141516171819202122def guanjia(game):#guanjia里面的game是形参 def inner(*args,**kwargs):#任何传递给inner的位置参数都会被args所接受，所有的关键字参数都被kwarg所接受 print(&quot;打开外挂&quot;) game(*arfs,**kwargs)#将形参的函数这里打开 v实参 #将一个元组或者字典一个个打开成位置参数和关键字参数 print(&quot;关闭外挂&quot;) return inner@guanjia #play_dnf = guanjia(play_dnf) 这里通过装饰器包装，这里的play_dnf是实参 def play_dnf(username ,password): print(&quot;我要开始玩dnf了&quot;,username ,password) print(&quot;你好啊，我叫赛利亚，今天是美好的一天&quot;！) @guanjia #play_lol = guanjia(play_lol)def play_lol(username,password,hero): print(&quot;我要开始玩lol了。&quot;,uesername,password,hero) print(&quot;德玛西亚&quot;)play dnf(&quot;admin&quot;,&quot;12345&quot;) #实际上是传入inner()里面play dnf(&quot;admin&quot;,&quot;232131&quot;,&quot;大盖伦&quot;)#因为玩每个游戏的所要调用的参数不同 所以inner()就要里面就要用*,**来接受所有参数 12345678910111213141516171819202122def wrapper1(fn): def inner(*args,**kwargs): print(&quot;这里是wrapper1进入&quot;) #第一步 ret = fn(*args,**kwargs): #进入wrapper.inner print(&quot;这里是wrapper1退出&quot;)#第五步 return ret return innerdef wrapper2(fn): def inner(*args,**kwargs): print(&quot;这里是wrapper2进入&quot;) #第二步 ret = fn(*args,**kwargs):#进入target print(&quot;这里是wrapper2退出&quot;)#第四步 return ret return inner@wrapper1@wrapper2def target(): print(&quot;我是目标&quot;)#第三步target()#输出 这里是wrapper1进入 这里是wrapper2进入 我是目标 这里是wrapper2退出 这里是wrapper1退出 迭代器terabl:可迭代的东西 .iterator:迭代器 可迭代的数据类型：str,list,tuple,dict,set,open() 可迭代的数据类型都会提供一个叫做迭代器的东西，这个迭代器可以帮我们把数据类型中的数据逐一的拿到 获取迭代器的两种方案： iter()内置函数可以直接拿到迭代器 next() 从迭代器里面拿到数据 __iter()__特殊方法 __next()__特殊方法 for循环里面一定是要拿迭代器的，所有不可迭代的东西不能用for循环 for循环里面一定有__next__出现 总结：迭代器统一了不同数据类型的遍历工作 迭代器本身也是可以迭代的 迭代器本身的特性： 1.只能向前，不能反复 2.特别节省内存 3.惰性机制 推导式简化代码，节省内存 语法： ​ 列表推导式：[数据 for循环 if判断] ​ 集合推导式：{数据 for循环 if判断} ​ 字典推导式：{k:v for循环 if判断} 不要不推导式妖魔化. (数据 for循环 if判断) —&gt; 不是元组推导式，根本就没有元组推导式。这个东西是生成器表达式 12345678910111213141516171819lst = []for i in range(10): lst.append(i)print(lst)#改成推导式lst[i for i in range(10)]print(lst)#请创建一个列表[1,3,5,7,9]lst[i for i in range(10) if i%2!=0]lst2 = [i for i in range(1,10,2)] #range(起始值，结束值，步长)#生成20件衣服lst = [f&quot;衣服&#123;i&#125; for i in range(20)&quot;]#将如下列表中所有的英文字母修改成大写lst3 = [&quot;bob&quot;,&quot;tom&quot;,&quot;tony&quot;,&quot;kevin&quot;]lst4 = [item.upper() for item in lst3]#请将下列的列表修改成字典，要求索引作为key,数据作为valuelst5 = [&quot;林俊杰&quot;，&quot;周杰伦&quot;,&quot;林志玲&quot;,&quot;刘德华&quot;,&quot;梁朝伟&quot;]dic6 = &#123;i:lst5[i] for i in range(len(lst5))&#125;#只要是代码可以调用的，都可以去试着调用，别局限思维 生成器语法:(数据 for循环 if判断) &gt;迭代器的特性，一次性的 12345678gen = (i**2 for i in range(10))#这是一个生成器 genderator 也是一个迭代器#gen.__next__() #调用next方法逐个取出数据 一次取出一个for item in gen: print(item)#生成器本质上是一个迭代器 ！！！！利用for循环取出后，里面的数据就没有了 lst = list(gen)#把迭代器转为列表print(lst)#输入这个列表就为空了，for循环已经把迭代器里面的内容全部取出来了，此时迭代器已经没内容了 生成器函数中有一个关键字yield 生成器函数执行的时候，并不会执行函数，得到的是一个生成器 yield:只要函数中出现了yield,他就是一个生成器函数 作用： 1，可以返回数据 2，可以分段的执行函数中的内容，通多__next__()可以执行执行到下一个yield位置 匿名函数lambda表达式 语法：变量 &#x3D; lambda 参数1,参数2,参数3…:返回值 j &#x3D; lambda a,b: a+b 内置函数zipzip：可以把多个 可迭代内容进行合并 e g.多个列表一起的话，可以将每个相应项和并 12345678910111213141516lst1 = [&#x27;梁朝伟&#x27;,&#x27;张国荣&#x27;,&#x27;周星驰&#x27;]lst2 = [&#x27;40&#x27;,&#x27;38&#x27;,&#x27;45&#x27;]lst3 = [&quot;重庆森林&quot;,&quot;阿飞正传&quot;,&quot;007&quot;]#没用函数的方法res = [] #创建一个列表放置数据for i in range(len(lst)):#迭代每个数据的位置 one = lst1[i] two = lst1[i] three = lst1[i] res.append((one,two,three))print(res)res = zip(lst1,lst2,lst3)#是一个迭代器#用迭代方法取出数据for item in res: print(item)#将每一类输出lst4 = list(res) #list()方法，将输出的东西生成一个列表 locals()函数和globals()函数12345678910111213a = 188print(locals()) #此时locals被写在全局作用域范围内，此时看到的就是全局作用域中的内容def func(): a=226 print(locals())#此时locals放在局部作用于范围，看到的就是局部作用域的内容func()c = 12print(globals())def func(): a = 36 print(globals()) #输出的还是当前全局范围的参数，global只能看全局范围的参数func() sorted：排序sorted() 作为 Python 内置函数之一，其功能是对序列（列表、元组、字典、集合、还包括字符串）进行排序。sorted() 函数的基本语法格式如下：list &#x3D; sorted(iterable, key&#x3D;None, reverse&#x3D;False) 其中，iterable 表示指定的序列，key 参数可以自定义排序规则；reverse 参数指定以升序（False，默认）还是降序（True）进行排序。sorted() 函数会返回一个排好序的列表。 123lst1 = [32413,523535,6,36346627,222,525]lst2 = sorted(lst1)print(lst2)#生成[6, 222, 525, 32413, 523535, 36346627] filter:过滤filter()函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。 fliter(function ,iterabel) 将iterabel(可迭代对象)的每一项数据拿出来交给前面函数执行 参数： 接受两个参数，第一个为函数，第二个为序列（可迭代对象），序列的每个元素作为参数传递给函数进行判断，然后返回True或False，最后将返回True的元素放到新列表中。 function 判断函数，interable 可迭代对象 和map不一样，只负责筛选，不会计算 12345lst = [&quot;周杰伦&quot;,&quot;周笔畅&quot;,&quot;周迅&quot;,&quot;张杰&quot;,&quot;黄渤&quot;]f = filter(lambda x : x.startswith(&quot;周&quot;),lst)#本质上filter是一个生成器#匹配姓周的名字print(list(f)) #startswith() 匹配开头数据#x.startswith(&quot;周&quot;), filter函数会筛选出开头为周的成员 map:映射将列表的东西给函数去计算 1234lst = [1,2,3,4,5,6,7]res = [item*item for item in lst]#推导式r = map(lambda x : x * x,lst) print(r) #x^2","categories":[{"name":"python笔记","slug":"python笔记","permalink":"http://zhoumuyun.com/categories/python%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://zhoumuyun.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Linux的sshd服务和文件的属性","slug":"linux","date":"2023-12-02T13:30:40.000Z","updated":"2023-12-03T08:28:01.304Z","comments":true,"path":"2023/12/02/linux/","link":"","permalink":"http://zhoumuyun.com/2023/12/02/linux/","excerpt":"此篇介绍了sshd的服务配置，Linux的文件属性","text":"此篇介绍了sshd的服务配置，Linux的文件属性 Linux的sshd服务查看ssh服务的状态 service sshd status 如果出现 Loaded: error (Reason: No such file or directory)，说明没有安装ssh服务如果出现Active: inactive (dead)说明已经安装了ssh服务，但是没有开启。按照第三步：开启ssh服务安装ssh服务yum -y install sshd 开启ssh服务systemctl start sshd 执行完命令后，用第一步：查看ssh服务状态的命令，如果出现以下提示Active: active (running) since Sun 2013-04-07 13:43:11 CST; 15s ago 说明你的ssh服务已经启动了 进入ssh配置文件更改vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config 光标移动到38行 ，将38行的#删掉 Windows连接打开poweshell ,输入ssh &#114;&#111;&#111;&#x74;&#x40;&#49;&#57;&#x32;&#x2e;&#x31;&#x36;&#56;&#x2e;&#x32;&#x30;&#x30;&#46;&#x31;&#51;&#x31;(目标主机地址) Linux文件属性linux用户对文件的权限(permission)分为读read、写write、执行execute和无权限。其中超级用户root拥有超级权限，对任何文件都具有读写执行的权限。 从文件的角度来讲，linux用户又分为三种，分别是文件拥有者owner、文件所属用户组group、其他用户others 运行ll指令时 每个字段分别代表 文件类型与权限 文件硬链接计数 文件所有者 文件所属用户组 文件大小 文件时间 文件名 文件类型与权限字段共有十个字符文件类型与权限第一个字符为文件类型属性-表示该文件为普通文件(regular file);d表示该文件为目录(directory);l表示该文件为指向其他文件的链接文件(link);b表示该文件为可随机访问的块设备文件(block);c表示该文件为只能按照字符顺序访问的字符设备文件(character);s表示该文件为用于数据传输的socket文件(socket);p表示该文件为用于先进先出方式数据传输的fifo文件(fifo); 九个字符rwxrwxrwx为文件权限属性,文件的权限包括读(r)、写(w)、执行(x)和无(-)权限每一组都是r、w、x和-字符的组合，r表示读权限，w表示写权限，x表示执行权限，－表示无权限 文件硬链接计数文件链接分为硬链接和软链接，该字段为文件的硬链接计数 文件所有者表示该文件的拥有者账号，文件拥有者都是在&#x2F;etc&#x2F;passwd文件中记录的合法用户账号 文件所属用户组文件所属用户组的作用是用来规定不是文件拥有者但是加入到该用户组中的用户对该文件的权限。文件大小文件时间字段表示文件的创建日期或者最后修改日期 文件名文件名以.开头的文件表示该文件是隐藏文件，其中.表示当前目录, ..表示上一级目录","categories":[{"name":"linux笔记","slug":"linux笔记","permalink":"http://zhoumuyun.com/categories/linux%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://zhoumuyun.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"怎么搭建自己的hexo博客","slug":"怎么搭建自己的hexo博客","date":"2023-12-02T08:31:06.000Z","updated":"2023-12-03T08:40:31.665Z","comments":true,"path":"2023/12/02/怎么搭建自己的hexo博客/","link":"","permalink":"http://zhoumuyun.com/2023/12/02/%E6%80%8E%E4%B9%88%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84hexo%E5%8D%9A%E5%AE%A2/","excerpt":"此篇介绍怎么用hexo和github搭建自己的博客，包括下载安装node、git、配置hexo、利用picgo做出自己的图床、配置typora","text":"此篇介绍怎么用hexo和github搭建自己的博客，包括下载安装node、git、配置hexo、利用picgo做出自己的图床、配置typora 安装node提前安装好(node.js)[https://nodejs.org/en] 点击左边的那个 20.10.0 安装GIt提前安装好(GIt)[https://git-scm.com/downloads] 1，进入网站，点击home 2，点击downloads 3，下载相应系统的版本 4，根据自己的处理器下载 提前注册一个GitHub账号 配置hexo1，创建一个目录放源文件，路径不要有中文 2，在当前目录(D:hexo)下进入cmd界面 3，使用npm命令安装Hexo, ​ npm install -g hexo-cli ​ hexo init blog​ cd blog​ hexo g 这是构建好后的目录 4，在cmd界面输入ssh-keygen -t rsa -C “邮件地址” 这里的邮件地址是GitHub的注册邮箱，成功后直接默认三次回车后，会在用户目录下生成C:\\Users\\19279.ssh 5，进入用户下的C:\\Users\\19279.ssh 6， 用记事本打开id_rsa.pub,将里面的密钥进行全选复制 7，打开GitHub设置，点击SSH and GPG keys选项，点击右上角New SSH key 8，将id_ras.pub里面的密钥复制到 9， 测试ssh -T git@github.com，看能不能连通，出现提示后表示已经接通 10，在hexo根目录也就是D:\\hexo\\blog，上面打开任务管理器下载hexo工具 npm install hexo-deployer-git –save 11，继续配置GitHub用户名和注册邮箱 git config –-global user.name “liuxunzhang”&#x2F;&#x2F; 你的github用户名，非昵称git config –-global user.email “xxx@qq.com“&#x2F;&#x2F; 填写你的github注册邮箱 12，在github上创建一个存储库 13， 存储库命名为GitHub的用户名＋github.io 14，打开hexo根目录，我这里是D:\\hexo\\blog，找到_config.yml文件，定位到文件最后，将最后改成这种形式 这是hexo的指令hexo n “我的博客” &#x3D;&#x3D; hexo new “我的博客” #新建文章hexo new page “pageName” #新建页面hexo g &#x3D;&#x3D; hexo generate #生成hexo s &#x3D;&#x3D; hexo server #启动服务预览hexo d &#x3D;&#x3D; hexo deploy #部署 hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令hexo version #查看Hexo的版本hexo generate #生成静态页面至public目录 hexo s -g #生成并本地预览hexo d -g #生成并上传 picgo图床的配置1，进入这个网站https://github.com/Molunerfinn/PicGo/releases 我这里下载的是picgo-setup-2.4.0-beta.6.exe版本 2，下载安装到一个文件夹，后面要用上 3，在GitHub新建一个存储库作为图床 4，点击头像&gt;打开setting&gt;GitHub&gt;打开最下面的Developer Settings&gt;Personal access tokens&gt;Token（classic) 5，点击右上角Generate new token&gt;Generate new token(classic) ​ 将里面的改成这样，名字可以随便取 6，生成token后全选复制&gt;然后打开picgo&gt;图床设置&gt; 名字可以随便取 仓库名是自己GitHub图床的名字 分支名字这里是main Token就是上面复制到那些 存储路径在自己的盘里面 7，将这个图床设置为默认图床 配置Typora1，打开typora&gt;点击文件&gt;打开偏好设置&gt; 2，打开图像设置 勾选前面四个&gt;将商创服务改成picgo,路径改成picgo的安装包位置","categories":[{"name":"怎么创建自己的博客","slug":"怎么创建自己的博客","permalink":"http://zhoumuyun.com/categories/%E6%80%8E%E4%B9%88%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"分享","slug":"分享","permalink":"http://zhoumuyun.com/tags/%E5%88%86%E4%BA%AB/"}]},{"title":"简单的木马病毒","slug":"new","date":"2023-12-01T12:42:09.000Z","updated":"2023-12-03T08:43:52.278Z","comments":true,"path":"2023/12/01/new/","link":"","permalink":"http://zhoumuyun.com/2023/12/01/new/","excerpt":"此篇包括telegram社工群的地址，永恒之黑的使用，利用mip22制作钓鱼网站，制作网页传播木马，伪装木马，压缩包携带木马，压缩包木马更换图标","text":"此篇包括telegram社工群的地址，永恒之黑的使用，利用mip22制作钓鱼网站，制作网页传播木马，伪装木马，压缩包携带木马，压缩包木马更换图标 社工库的电报群地址利用telegram进入社工群，获取他人信息 电报机器人群聊链接 社工庫机器人: t.me&#x2F;aishegongkubot?start&#x3D;AISGK_HBEIR85Xhttps://t.me/DATA_007bot?start=8989324940https://t.me/pingansgk_bot?start=ee95c5680fhttps://t.me/JokerSGKbot?start=87OE61VQhttps://t.me/PyramidNetBot?start=pRg3K08https://t.me/XingDun2Bot?start=4eoHoLE永恒之黑利用python打开代码让别人的电脑蓝屏 下载老师给的CVE-2020-0796-PoC 解压 打开解压的目录 在目录打开终端（在上面输入cmd进入终端） 安装打开文件所需要的模块 cryptography 运行文件，系统会提醒缺少什么模块 在后面添加源可以让pip下载更快（&#x2F;-i https://pypi.tuna.tsinghua.edu.cn/simple) 输入代码 python CVE-2020-0796.py ＋IP地址(目标主机的IP地址) 利用mip22制作钓鱼网站配置网络代理打开Allow LAN开关 找到自己的代理的IP(Allow LAN)英文旁边的连接符（三角形）和代理端口（port) 进入Linux shell设置代理，让Linux虚拟机能够访问到GitHub vim &#x2F;etc&#x2F;proxychains4.conf 用vim编辑器打开代理文件 找到最后一行 将socks4改为socks5 ＋ clash上的代理地址和端口 proxychains4 git clone https://github.com/makdosx/mip22 利用代理网络在GitHub下载mip22 proxychains4 -q bash .&#x2F;mip22.sh 执行mip22 进入mip22界面 按1进入钓鱼界面网站 输入序号选择钓鱼网站 按3开始收集信息 利用网页传播木马在虚拟机下载安装phpstudy软件 在首页打开Apache 点开网站&gt;管理&gt;打开根目录 把www目录里面的东西全部删除 创建index.html文件 打开vscode,创造html的模板，在中间输入 导入flash.js文件，在文件代码最下方代码 “href&#x3D;”地址改成自己虚拟机的地址 加上点击后要下载文件的名称。 这里是 href&#x3D;’192.168.200.128&#x2F;flash.exe’ :从192.168.200.128访问，跳出flash.exe下载 进入网站后弹出flash木马，点击即下载flash.exe 伪装网站让木马更加真实打开kali linux proxychains4 -q bash .&#x2F;mip22.sh(这里进入了相对目录下，在mip22目录下) 在虚拟机kali打开mip22 进入钓鱼网站界面，下载钓鱼网站 将这两个文件打包压缩，然后将压缩包剪切到 C:\\phpstudy_pro\\WWW，进行解压缩 将html文件改成index.html,并在里面插入 利用大灰狼远程控制系统关闭自身的病毒查杀和防火墙 解压大灰狼压缩包 打开大灰狼 输入自己的IP地址 生成木马文件 发送到目标电脑 目标电脑点击后 可以控制对方 利用压缩包携带木马文件准备好想要伪装的软件安装包和木马 这里将flash安装包和木马一起压缩，勾选创建自解压格式压缩文件 点击高级&gt;自解压选项 在常规选项输入计算机的目录：C:\\windows\\temp（解压的地方） 打开设置选项，输入两个文件解压后的路径 C:\\windows\\temp\\flashcenter_pp_ax_install_cn.exe C:\\windows\\temp\\flash.exe 给压缩包换图标，让病毒更加真实下载Restorator，把想要换图标的两个包拖到软件 把要替换的图标替换过去，然后保存","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://zhoumuyun.com/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://zhoumuyun.com/tags/%E7%AC%94%E8%AE%B0/"}]}],"categories":[{"name":"python笔记","slug":"python笔记","permalink":"http://zhoumuyun.com/categories/python%E7%AC%94%E8%AE%B0/"},{"name":"linux笔记","slug":"linux笔记","permalink":"http://zhoumuyun.com/categories/linux%E7%AC%94%E8%AE%B0/"},{"name":"怎么创建自己的博客","slug":"怎么创建自己的博客","permalink":"http://zhoumuyun.com/categories/%E6%80%8E%E4%B9%88%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"},{"name":"网络安全","slug":"网络安全","permalink":"http://zhoumuyun.com/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://zhoumuyun.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"分享","slug":"分享","permalink":"http://zhoumuyun.com/tags/%E5%88%86%E4%BA%AB/"}]}